/************************************************************************************************** * FILE: tc3xx_bsp_example_4c.ld * UC ARCHITECTURE: *     TC3xx * UC FAMILY: *     4 core variant * DESCRIPTION: *     Application linker file describing only elements used in BSP example *     to keep the file as simple as possible. *     It locates object sections to memory regions defined in <uC>_memory *     linker file via predefined ALIASES. * FILE HISTORY: *     V1    05.2020    RO *     - Base example reference ************************************************************************************************** * Copyright (C) 2015-2020 HighTec EDV-Systeme GmbH. All rights reserved. * This is proprietary software. Any use of the software requires a written * license agreement with HighTec EDV-Systeme GmbH. Please contact for * detailed license information: info@hightec-rt.com. *************************************************************************************************//* ================================================================================================ * PREDEFINED OUTPUT SECTIONS TO MEMORY REGION ALIASES * Aliases allow a quick change in memory placement * ==============================================================================================*//* BMHD sections *//* BMHD是AURIX芯片启动用的Boot Header, 告诉硬件从哪里启动. *//* 定义两个区域别名, 指向flash里不同的BMHD区域, 一个是原始的(_orig), 一个是拷贝的(_copy), 方便后面生成UCB(User Configuration Block) */REGION_ALIAS("BMHD_ORIG", ucb_bmhd_orig)REGION_ALIAS("BMHD_COPY", ucb_bmhd_copy)/* CRT0 Boot Code Start */REGION_ALIAS("BOOT", int_flash0)  /* CRT0是C运行时初始化代码(程序最开头执行的那一小段汇编, 初始化栈、BSS段等) */                                  /* 这里把"BOOT"段映射到int_flash0, 也就是内部Flash0. 说明启动代码放在CPU0的内部Flash *//* BSP Interrupt handler table in RAM */REGION_ALIAS("BSP_ISR_HANDLERS_CPU0_", pspr_cpu0)  /* 每个CPU核心的中断表都放在各自的PSPR(Program Scratchpad RAM)中 */REGION_ALIAS("BSP_ISR_HANDLERS_CPU1_", pspr_cpu1)REGION_ALIAS("BSP_ISR_HANDLERS_CPU2_", pspr_cpu2)REGION_ALIAS("BSP_ISR_HANDLERS_CPU3_", pspr_cpu3)/* Core0: Output sections to memory region mapping */REGION_ALIAS("CODE_CPU0_", int_flash0)  /* CODE_CPU0_, 程序代码(.text), int_flash0, CPU0的内部闪存 */REGION_ALIAS("RODATA_CPU0_", int_flash0)  /* RODATA_CPU0_, 只读数据(.rodata), int_flash0, 常量区域 */REGION_ALIAS("RAMCODE_CPU0_", pspr_cpu0)  /* RAMCODE_CPU0_, 运行时放RAM的函数, pspr_cpu0, 高速本地RAM */REGION_ALIAS("DATA_DSPR_CPU0_", dspr_cpu0)  /* DATA_DSPR_CPU0_, 普通全局变量, dspr_cpu0, Data Scratchpad RAM(核心专用) */REGION_ALIAS("DATA_DLMU_CPU0_", dlmu_cpu0)  /* DATA_DLMU_CPU0_, 可共享数据, dlmu_cpu0, Local Memory Unit(跨核共享RAM) *//* Core1: Output sections to memory region mapping */REGION_ALIAS("CODE_CPU1_", int_flash1)REGION_ALIAS("RODATA_CPU1_", int_flash1)REGION_ALIAS("RAMCODE_CPU1_", pspr_cpu1)REGION_ALIAS("DATA_DSPR_CPU1_", dspr_cpu1)REGION_ALIAS("DATA_DLMU_CPU1_", dlmu_cpu1)/* Core2: Output sections to memory region mapping */REGION_ALIAS("CODE_CPU2_", int_flash2)REGION_ALIAS("RODATA_CPU2_", int_flash2)REGION_ALIAS("RAMCODE_CPU2_", pspr_cpu2)REGION_ALIAS("DATA_DSPR_CPU2_", dspr_cpu2)REGION_ALIAS("DATA_DLMU_CPU2_", dlmu_cpu2)/* Core3: Output sections to memory region mapping */REGION_ALIAS("CODE_CPU3_", int_flash3)REGION_ALIAS("RODATA_CPU3_", int_flash3)REGION_ALIAS("RAMCODE_CPU3_", pspr_cpu3)REGION_ALIAS("DATA_DSPR_CPU3_", dspr_cpu3)REGION_ALIAS("DATA_DLMU_CPU3_", dlmu_cpu3)/* Common code and data *//* 公共代码或共享变量, 不属于某个特定核 *//* 它们被放进LMU(Local Memory Unit), 也就是所有核心都能访问的共享RAM区. */REGION_ALIAS("CODE", int_flash0)REGION_ALIAS("RODATA", int_flash0)REGION_ALIAS("DATA", lmu0_noncached)REGION_ALIAS("RAM_CODE", lmu0_noncached)/* ================================================================================================ * PREDEFINED CONSTANTS * ==============================================================================================*//* Shared Global Stack as defined by AURIX architecture (PSW.IS = 1) * the User stack is left on eventual User or RTOS control (PSW.IS = 0) */SHARED_STACK_SIZE = 4K;  /* 共享栈大小4KB *//* CSA dedicated memory region size defined as * (Number of CSA regions x CSA entry size) where 256 entries is Maximum */CSA_REGIONS = 256;  /* 有256个上下文块 */CSA_SIZE = CSA_REGIONS * 64;  /* 每块64字节, 所以总共256 * 64 = 16KB *//* General HEAP is case one uses certain stdlib functions */__HEAP_SIZE = DEFINED (__HEAP_SIZE) ? __HEAP_SIZE : 4K;  /* malloc()或printf()这类标准库函数, 就需要一个堆 *//* ================================================================================================ * SECTIONS: BMHD headers * ==============================================================================================*//* 芯片启动配置表 *//* 每个Flash Bank都有自己的Boot Header区, 用于告诉硬件: 代码起始地址在哪儿; 校验信息(CRC); Boot配置标志; Watchdog初始设置等 */SECTIONS{  /* Boot Mode Header - original values */  .bmhd_0_orig 0xaf400000 : { KEEP (*(.bmhd_0_orig)) } > BMHD_ORIG  /* KEEP() 表示: 即使没有被引用, 也强制保留这些段, 防止链接器优化掉 */  .bmhd_1_orig 0xaf400200 : { KEEP (*(.bmhd_1_orig)) } > BMHD_ORIG  .bmhd_2_orig 0xaf400400 : { KEEP (*(.bmhd_2_orig)) } > BMHD_ORIG  .bmhd_3_orig 0xaf400600 : { KEEP (*(.bmhd_3_orig)) } > BMHD_ORIG  /* Boot Mode Header - copy values */  .bmhd_0_copy 0xaf401000 : { KEEP (*(.bmhd_0_copy)) } > BMHD_COPY  .bmhd_1_copy 0xaf401200 : { KEEP (*(.bmhd_1_copy)) } > BMHD_COPY  .bmhd_2_copy 0xaf401400 : { KEEP (*(.bmhd_2_copy)) } > BMHD_COPY  .bmhd_3_copy 0xaf401600 : { KEEP (*(.bmhd_3_copy)) } > BMHD_COPY}/* ================================================================================================ * SECTIONS: Application BOOT code * Address pointed by BMHD start address value * ==============================================================================================*/SECTIONS{  .crt0_boot : { KEEP (*(.crt0_boot.code)) } > BOOT  /* 最早执行的C启动汇编(初始化堆栈、BSS段、跳转到main()). 放在BOOT区域(也就是int_flash0) */}/* ================================================================================================ * SECTIONS: Reset Default TRAP handlers provided by BSP * the TRAP table is shared across cores * BTV register value after reset is 0xA0000100 (0x80000100) * ==============================================================================================*//* TRAP表就是CPU的异常向量表, 相当于"中断表的表" *//* TriCore架构里, 每种错误(如地址错误、除零、堆栈溢出等)都有一个TRAP向量 */SECTIONS{  .bsp_trap_reset 0x80000100 :  /* 放在地址0x80000100: 这是硬件重置后BTV(Base Trap Vector)寄存器指向的位置 */  {    KEEP (*(.bsp_trap_vector_table))  /* .bsp_trap.vector_table: 向量表本身; */    KEEP (*(.bsp_trap_handlers))  /* .bsp_trap.handlers: 实际的异常处理函数 */  } > CODE_CPU0_  /* 存放在CODE_CPU0_, 也就是CPU0的代码区(int_flash0) */}/* ================================================================================================ * SECTIONS: BSP Interrupt tables * BSP provided Interrupt vector table and ISR Handler tables for each core * BSP code set BIV register to core corresponding Base address * ==============================================================================================*/SECTIONS{  /* 每个核的中断向量表(IVT), 被放到各自的DLMU */  .CPU0.bsp_isr_vector_table : { KEEP (*(.bsp_isr_vector_table_cpu0)) } > CODE_CPU0_  .CPU1.bsp_isr_vector_table : { KEEP (*(.bsp_isr_vector_table_cpu1)) } > CODE_CPU1_  .CPU2.bsp_isr_vector_table : { KEEP (*(.bsp_isr_vector_table_cpu2)) } > CODE_CPU2_  .CPU3.bsp_isr_vector_table : { KEEP (*(.bsp_isr_vector_table_cpu3)) } > CODE_CPU3_}SECTIONS{  /* ISR处理表(Handler Table), 被放到各自的PSPR */  .CPU0.bsp_isr_ram_table (NOLOAD) : { *(.BspIsrRamTable_Cpu0) } > BSP_ISR_HANDLERS_CPU0_  .CPU1.bsp_isr_ram_table (NOLOAD) : { *(.BspIsrRamTable_Cpu1) } > BSP_ISR_HANDLERS_CPU1_  .CPU2.bsp_isr_ram_table (NOLOAD) : { *(.BspIsrRamTable_Cpu2) } > BSP_ISR_HANDLERS_CPU2_  .CPU3.bsp_isr_ram_table (NOLOAD) : { *(.BspIsrRamTable_Cpu3) } > BSP_ISR_HANDLERS_CPU3_}/* ================================================================================================ * SECTIONS: Cores' CSA regions * Each core has its own CSA region list * ==============================================================================================*//* 当函数调用或任务切换时, 硬件自动把寄存器内容压栈(Context List) *//* (NOLOAD): 告诉链接器——这段不会在程序下载时写入Flash(它只在运行时用RAM) *//* . = ALIGN(64): 地址对齐到64字节边界(每个CSA块固定64字节) *//* __CSA_BASE_CPU0_ = .;: 定义一个符号, 标记当前CSA段起始地址 *//* . += CSA_SIZE;: 预留一整块区域, 大小是前面定义的CSA_SIZE = 256 * 64 = 16K *//* > DATA_DSPR_CPU0_: 告诉链接器把它放到CPU0的DSPR(Data ScratchPad RAM, 本地高速数据RAM)里 */SECTIONS{  .CPU0.csa (NOLOAD) : { . = ALIGN(64); __CSA_BASE_CPU0_ = .; . += CSA_SIZE; } > DATA_DSPR_CPU0_  .CPU1.csa (NOLOAD) : { . = ALIGN(64); __CSA_BASE_CPU1_ = .; . += CSA_SIZE; } > DATA_DSPR_CPU1_  .CPU2.csa (NOLOAD) : { . = ALIGN(64); __CSA_BASE_CPU2_ = .; . += CSA_SIZE; } > DATA_DSPR_CPU2_  .CPU3.csa (NOLOAD) : { . = ALIGN(64); __CSA_BASE_CPU3_ = .; . += CSA_SIZE; } > DATA_DSPR_CPU3_}/* ================================================================================================ * SECTIONS: Cores' Shared Stacks * Each core has its own Shared stack area (PSW.IS = 1) * ==============================================================================================*//* 每个核心都定义自己的栈段.CPUx.stack *//* . = ALIGN(8): 地址按8字节对齐(栈操作要求对齐) *//* __STACK_BASE_CPUx_ = .;: 定义栈底地址(堆栈开始位置) *//* . += SHARED_STACK_SIZE;: 预留固定栈大小(前面定义为4 KB) *//* > DATA_DSPR_CPUx_: 放在各核心自己的DSPR RAM中 */SECTIONS{  .CPU0.stack : { . = ALIGN(8); __STACK_BASE_CPU0_ = .; . += SHARED_STACK_SIZE; } > DATA_DSPR_CPU0_  .CPU1.stack : { . = ALIGN(8); __STACK_BASE_CPU1_ = .; . += SHARED_STACK_SIZE; } > DATA_DSPR_CPU1_  .CPU2.stack : { . = ALIGN(8); __STACK_BASE_CPU2_ = .; . += SHARED_STACK_SIZE; } > DATA_DSPR_CPU2_  .CPU3.stack : { . = ALIGN(8); __STACK_BASE_CPU3_ = .; . += SHARED_STACK_SIZE; } > DATA_DSPR_CPU3_}/* ================================================================================================ * SECTIONS: CORE 0 dedicated sections * In the example they are Empty, but user might used them to play * with core specific placement * ==============================================================================================*//* AT > RODATA_CPU0_" 是重点: * ">"指运行时所在区域(VMA), "AT >"指镜像中加载位置(LMA) * 也就是说程序镜像里这些数据存放在Flash(RODATA_CPU0_), 启动时会拷贝到RAM执行*/SECTIONS{  .CPU0.code : { } > CODE_CPU0_  /* .CPU0.code: 普通代码段/> CODE_CPU0_: 放在CPU0对应Flash */  .CPU0.ramcode : { } > RAMCODE_CPU0_ AT > RODATA_CPU0_  /* .CPU0.ramcode: 运行时要拷贝到RAM执行的代码(如时间关键函数)/执行地址:RAMCODE_CPU0_,加载地址:RODATA_CPU0_, 意味着程序启动时会把这段从Flash拷到RAM*/  .CPU0.rodata : { } > RODATA_CPU0_  /* .CPU0.rodata: 只读常量区/> RODATA_CPU0_:常量放Flash */  .CPU0.data : { } > DATA_DSPR_CPU0_ AT > RODATA_CPU0_  /* .CPU0.data: 已初始化全局变量/运行地址: DATA_DSPR_CPU0_, 加载地址:RODATA_CPU0_, 启动时从Flash拷贝初始值到RAM */  .CPU0.bss : { } > DATA_DSPR_CPU0_  /* .CPU0.bss: 未初始化全局变量/> DATA_DSPR_CPU0_: 启动时清零即可 */}/* ================================================================================================ * SECTIONS: CORE 1 dedicated sections * In the example they are Empty, but user might used them to play * with core specific placement * ==============================================================================================*/SECTIONS{  .CPU1.code : { } > CODE_CPU1_  .CPU1.ramcode : { } > RAMCODE_CPU1_ AT > RODATA_CPU1_  .CPU1.rodata : { } > RODATA_CPU1_  .CPU1.data : { } > DATA_DSPR_CPU1_ AT > RODATA_CPU1_  .CPU1.bss : { } > DATA_DSPR_CPU1_}/* ================================================================================================ * SECTIONS: CORE 2 dedicated sections * In the example they are Empty, but user might used them to play * with core specific placement * ==============================================================================================*/SECTIONS{  .CPU2.code : { } > CODE_CPU2_  .CPU2.ramcode : { } > RAMCODE_CPU2_ AT > RODATA_CPU2_  .CPU2.rodata : { } > RODATA_CPU2_  .CPU2.data : { } > DATA_DSPR_CPU2_ AT > RODATA_CPU2_  .CPU2.bss : { } > DATA_DSPR_CPU2_}/* ================================================================================================ * SECTIONS: CORE 3 dedicated sections * In the example they are Empty, but user might used them to play * with core specific placement * ==============================================================================================*/SECTIONS{  .CPU3.code : { } > CODE_CPU3_  .CPU3.ramcode : { } > RAMCODE_CPU3_ AT > RODATA_CPU3_  .CPU3.rodata : { } > RODATA_CPU3_  .CPU3.data : { } > DATA_DSPR_CPU3_ AT > RODATA_CPU3_  .CPU3.bss : { } > DATA_DSPR_CPU3_}/* ================================================================================================ * SECTIONS: COMMON (shared) sections * by default, all example sections are located here * ==============================================================================================*//* 如果某个函数、变量、常量没指定属于哪个CPU核, 就默认放在这部分 */SECTIONS{  /* 收集所有输入文件中名为.text* 的段(即函数代码), 放到逻辑内存区域CODE(前面REGION_ALIAS("CODE", int_flash0)已定义为主Flash) */  .code :	  {    *(.text*)  } > CODE  /* 把标记为.ramcode* 的函数段放进RAM区(> RAM_CODE). 但它们的**镜像(加载位置)**仍在Flash(AT > RODATA) */  /* 启动时系统会把这些函数从Flash拷到RAM, 再从RAM执行. 适合那些需要极高实时性的函数(例如ADC采样ISR、PWM更新函数) */  .ramcode :  {    *(.ramcode*)  } > RAM_CODE AT > RODATA  /* 就是const数据, 比如字符串常量、查表数据等, 存放在Flash区 */  .rodata :  {    *(.rodata*)  } > RODATA  /* C++ 全局对象的构造函数列表. 链接器会把所有.ctors段的函数指针放进一个表 */  .ctors : ALIGN(4) FLAGS(arl)  {    __CTOR_LIST__ = .;    LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2)    KEEP (*(.ctors));    LONG(0);    __CTOR_END__ = .;	  } > RODATA  /* TriCore编译器支持"小数据区"优化(–msdata开关) */  /* .sdata2 → 小型只读数据(常量) */  .sdata2 :  {    *(.sdata2*)  } > RODATA  /* .sdata → 小型已初始化全局变量 */  .sdata :  {    *(.sdata*)  } > DATA AT > RODATA  /* .sbss → 小型未初始化变量 */  .sbss :  {    *(.sbss*)  } > DATA  /* .data: 初始化的全局变量, 例如int x = 5; */  /* 存放在RAM(> DATA); 初始值存储在Flash(AT > RODATA); 启动时复制过来 */  .data :  {    *(.data*)  } > DATA AT > RODATA  /* .bss: 未初始化的全局变量, 例如int y; */  /* 放在RAM(> DATA); 启动时清零 */  /* *(COMMON): 处理老式编译器的"common symbol"——防止重复定义全局变量时出错 */  .bss :  {    *(.bss*);    *(COMMON);  } > DATA  /* ALIGN(8): 地址对齐到8字节 */  /* . += __HEAP_SIZE;: 在内存中占出一块连续空间, 用作堆(malloc/new), 放在DATA区, 即RAM */  .heap : ALIGN(8)  {    . += __HEAP_SIZE;  } > DATA}/* ================================================================================================ * SECTIONS: CLEAR & COPY TABLES with END delimiter to support crt0 init * clear_table: *    data memory ranges to clear to zero * copy_table: *    data memory ranges that needs to be value initialized *    (init values are stored in FLASH and copied to RAM) * Each core has its own table to process during its init to allow multicore execution. * Shared resources are inserted to Core[0] tables (the RESET core) * ==============================================================================================*//* "清零与拷贝表(Clear & Copy Tables)"段, 专门服务于CRT0启动初始化阶段 *//* 当MCU上电、跳入_start或__start时,C运行时系统(CRT0)必须知道—— *//* 哪些内存段要清零(bss), 哪些要从Flash拷到RAM(data/ramcode) *//* 这部分就是在生成这两张"任务清单表", 让启动代码自动完成初始化 *//* 启动流程上, 大致这样: * 1. Core0上电启动; * 2. CRT0读.CPU0.clear_sec → 清空.bss、.sbss、.heap; * 3. CRT0读.CPU0.copy_sec → 把.data初值从Flash拷到RAM; * 4. 其他核(CPU1–3)启动时, 各自读自己的.clear_sec、.copy_sec; * 5. 执行main() */SECTIONS{  /*-------------------------------------------------------------------------------------------*/  /* ADDR(.CPU0.bss): .CPU0.bss段的起始地址(RAM) */  /* SIZEOF(.CPU0.bss): .CPU0.bss段长度 */  /* LONG(-1); LONG(-1); 结尾标志(表示清零表到此结束) */  .CPU0.clear_sec :  {    LONG(ADDR(.CPU0.bss)); LONG(SIZEOF(.CPU0.bss));    LONG(ADDR(.sbss)); LONG(SIZEOF(.sbss));    LONG(ADDR(.bss)); LONG(SIZEOF(.bss));    LONG(ADDR(.heap)); LONG(SIZEOF(.heap));    LONG(-1); LONG(-1);  } > RODATA_CPU0_  /* 源地址(Flash, LOADADDR), 目标地址(RAM, ADDR), 长度(SIZEOF) */  /* 启动时CRT0会循环读取这些三元组, 执行memcpy(dst, src, len) */  .CPU0.copy_sec :  {    LONG(LOADADDR(.CPU0.ramcode)); LONG(ADDR(.CPU0.ramcode)); LONG(SIZEOF(.CPU0.ramcode));    LONG(LOADADDR(.CPU0.data)); LONG(ADDR(.CPU0.data)); LONG(SIZEOF(.CPU0.data));    LONG(LOADADDR(.ramcode)); LONG(ADDR(.ramcode)); LONG(SIZEOF(.ramcode));    LONG(LOADADDR(.sdata)); LONG(ADDR(.sdata)); LONG(SIZEOF(.sdata));    LONG(LOADADDR(.data)); LONG(ADDR(.data)); LONG(SIZEOF(.data));    LONG(-1); LONG(-1); LONG(-1);  } > RODATA_CPU0_  /*-------------------------------------------------------------------------------------------*/  .CPU1.clear_sec :  {    LONG(ADDR(.CPU1.bss)); LONG(SIZEOF(.CPU1.bss));    LONG(-1); LONG(-1);  } > RODATA_CPU1_  .CPU1.copy_sec :  {    LONG(LOADADDR(.CPU1.ramcode)); LONG(0 + ADDR(.CPU1.ramcode)); LONG(SIZEOF(.CPU1.ramcode));    LONG(LOADADDR(.CPU1.data)); LONG(ADDR(.CPU1.data)); LONG(SIZEOF(.CPU1.data));    LONG(-1); LONG(-1); LONG(-1);  } > RODATA_CPU1_  /*-------------------------------------------------------------------------------------------*/  .CPU2.clear_sec :  {    LONG(ADDR(.CPU2.bss)); LONG(SIZEOF(.CPU2.bss));    LONG(-1); LONG(-1);  } > RODATA_CPU2_  .CPU2.copy_sec :  {    LONG(LOADADDR(.CPU2.ramcode)); LONG(0 + ADDR(.CPU2.ramcode)); LONG(SIZEOF(.CPU2.ramcode));    LONG(LOADADDR(.CPU2.data)); LONG(0 + ADDR(.CPU2.data)); LONG(SIZEOF(.CPU2.data));    LONG(-1); LONG(-1); LONG(-1);  } > RODATA_CPU2_  /*-------------------------------------------------------------------------------------------*/  .CPU3.clear_sec :  {    LONG(ADDR(.CPU3.bss)); LONG(SIZEOF(.CPU3.bss));    LONG(-1); LONG(-1);  } > RODATA_CPU3_  .CPU3.copy_sec :  {    LONG(LOADADDR(.CPU3.ramcode)); LONG(0 + ADDR(.CPU3.ramcode)); LONG(SIZEOF(.CPU3.ramcode));    LONG(LOADADDR(.CPU3.data)); LONG(0 + ADDR(.CPU3.data)); LONG(SIZEOF(.CPU3.data));    LONG(-1); LONG(-1); LONG(-1);  } > RODATA_CPU3_}/* ================================================================================================ * Linker Symbols * ==============================================================================================*//* TriCore架构支持"小数据区寻址"功能, 比普通32位绝对寻址快得多 * 它有两个专用寄存器: * A0 → 指向.sdata2区(只读小常量) * A1 → 指向.sdata区(可读写小变量) * 编译器在编译时会用这些寄存器进行短地址访问 */_SMALL_DATA2_ = ADDR(.sdata2) + 0x8000;  /* TriCore的小数据寻址范围是±32KB(即±0x8000) */_SMALL_DATA_ = ADDR(.sdata) + 0x8000;  /* _SMALL_DATA_是A1的初始化值. 它告诉编译器, 小型全局变量都放在这个区域附近, 以便快速访问 *//* Expected HEAP SYMBOLS */__HEAP = ADDR(.heap);  /* __HEAP: 堆区起始地址; */__HEAP_END = ADDR(.heap) + SIZEOF(.heap);  /* __HEAP_END: 堆区末尾(即最大可用地址) *//* ================================================================================================ * CRT0 CONFIG STRUCTURE * Initialization structure for uC Cores used in crt0 startup code * Each core has itw one table entry. * ==============================================================================================*//* CRT0初始化配置表(C Runtime 0 Config Table) * 启动代码在上电时读取的配置块, 用来告诉每个CPU核: * "栈在哪?CSA区多大? 小数据寄存器(A0/A1)初始化值是多少? 要清零/拷贝哪些区域?" *//* Core0上电后,CRT0会读这一行, 按顺序初始化堆栈、CSA、小数据寄存器、变量清零、内存拷贝、构造函数调用 *//* 这是整个系统"从空白RAM到能跑main()"的全过程参数来源 */SECTIONS{  .crt0_config : ALIGN(4)  /* .crt0_config: 输出段名称; ALIGN(4):4字节对齐; */  {    PROVIDE(__crt0_config = .);          /* 定义符号__crt0_config指向此段的起始地址, 并"懒加载式"声明它(即便用户没显式声明, 也会自动创建) */    /* Core[0] */    LONG(ADDR(.CPU0.stack));           /* Core0的栈基地址: 启动时设置SP */    LONG(SIZEOF(.CPU0.stack));         /* 栈空间大小: 给中断和任务留栈 */    LONG(ADDR(.CPU0.csa));             /* CSA起始地址: 初始化上下文保存区 */    LONG(SIZEOF(.CPU0.csa));           /* CSA区大小: 决定多少硬件栈帧 */    LONG(_SMALL_DATA_);                /* 小变量区基址(A1): 初始化寄存器A1 */    LONG(_SMALL_DATA2_);               /* 小常量区基址(A0): 初始化寄存器A0 */    LONG(0);                           /* 占位, 未来可扩展更多小数据区 */    LONG(0);                           /* 占位, 未来可扩展更多小数据区 */    LONG(ADDR(.CPU0.clear_sec));       /* 清零表地址: 指向.CPU0.clear_sec */    LONG(ADDR(.CPU0.copy_sec));        /* 拷贝表地址: 指向.CPU0.copy_sec */    LONG(__CTOR_LIST__);               /* 支持C++: 对象初始化 */    /* Core[1] */    LONG(ADDR(.CPU1.stack));           /* STACK address */    LONG(SIZEOF(.CPU1.stack));         /* STACK size */    LONG(ADDR(.CPU1.csa));             /* CSA address */    LONG(SIZEOF(.CPU1.csa));           /* CSA size */    LONG(_SMALL_DATA_);                /* SDATA address */    LONG(_SMALL_DATA2_);               /* SDATA2 address */    LONG(0);                           /* SDATA3 address */    LONG(0);                           /* SDATA4 address */    LONG(ADDR(.CPU1.clear_sec) );      /* CLEAR table */    LONG(ADDR(.CPU1.copy_sec));        /* COPY table */    LONG(0);                           /* CTOR table */    /* Core[2] */    LONG(ADDR(.CPU2.stack));           /* STACK address */    LONG(SIZEOF(.CPU2.stack));         /* STACK size */    LONG(ADDR(.CPU2.csa));             /* CSA address */    LONG(SIZEOF(.CPU2.csa));           /* CSA size */    LONG(_SMALL_DATA_);                /* SDATA address */    LONG(_SMALL_DATA2_);               /* SDATA2 address */    LONG(0);                           /* SDATA3 address */    LONG(0);                           /* SDATA4 address */    LONG(ADDR(.CPU2.clear_sec));       /* CLEAR table */    LONG(ADDR(.CPU2.copy_sec));        /* COPY table */    LONG(0);                           /* CTOR table */    /* Core[3] */    LONG(ADDR(.CPU3.stack));           /* STACK address */    LONG(SIZEOF(.CPU3.stack));         /* STACK size */    LONG(ADDR(.CPU3.csa));             /* CSA address */    LONG(SIZEOF(.CPU3.csa));           /* CSA size */    LONG(_SMALL_DATA_);                /* SDATA address */    LONG(_SMALL_DATA2_);               /* SDATA3 address */    LONG(0);                           /* SDATA3 address */    LONG(0);                           /* SDATA4 address */    LONG(ADDR(.CPU3.clear_sec));       /* CLEAR table */    LONG(ADDR(.CPU3.copy_sec));        /* COPY table */    LONG(0);                           /* CTOR table */  } > RODATA}/* ================================================================================================ * DWARF debug sections and others * Symbols in the DWARF debugging sections are relative to the * beginning of the section, so we begin them at 0. * ==============================================================================================*//* 收尾调试信息部分, 主要处理DWARF调试段(debug sections). 不会被下载到目标MCU里执行, 只存在于ELF文件中, 用于调试器(比如Lauterbach、UDE、GDB)做符号、源文件、变量映射等 *//* DWARF是一种 调试信息格式标准, 用于描述: 源代码与汇编地址之间的映射; 变量、函数、类型信息;调用栈、作用域、行号等 * 调试器根据这些信息才能: 看到C源代码; 打断点; 单步执行; 查看局部变量和结构体成员 *//* 名字前缀.debug_是DWARF标准定义的约定. ELF的"调试专用节(debug sections)".  * 不会链接进最终的bin/hex文件; * 只保留在ELF文件中; * 编译时由-g选项生成; * 链接器会把不同对象文件的debug段合并到这些统一段里 *//* 为什么全都以0 : 开头? 因为: * 它们不属于MCU的可执行或可加载内存; 只存在于ELF文件符号表里; * 链接器把它们"逻辑上放在0地址", 方便调试工具解析, 因此不会干扰程序运行 */SECTIONS{	  /* DWARF 1 */  .comment 0 : { *(.comment) }  /* .comment: 保存编译器版本号、构建信息 */  .debug 0 : { *(.debug) }      /* .debug: 旧格式的符号信息; */  .line 0 : { *(.line) }        /* .line: 源代码行号映射 */  /* GNU DWARF 1 extensions */  .debug_srcinfo 0 : { *(.debug_srcinfo) }   /* .debug_srcinfo: 源文件路径 */  .debug_sfnames 0 : { *(.debug_sfnames) }   /* .debug_sfnames: 函数或符号名映射 */  /* DWARF 1.1 and DWARF 2 */  .debug_aranges 0 : { *(.debug_aranges) }   /* .debug_aranges: 记录函数/变量的地址范围 */   .debug_pubnames 0 : { *(.debug_pubnames) } /* .debug_pubnames: 公共符号(可全局调试可见) */                                                                                 /* DWARF 2 */  .debug_info 0 : { *(.debug_info) }         /* .debug_info	主调试信息表(DIE树)	变量、函数、作用域描述 */  .debug_abbrev 0 : { *(.debug_abbrev) }     /* .debug_abbrev	缩写表	提供debug_info的格式模板 */   .debug_line 0 : { *(.debug_line) }         /* .debug_line	行号表	源文件行号 ↔ 地址 */            .debug_frame 0 : { *(.debug_frame) }       /* .debug_frame	栈帧信息	调试器能回溯函数调用栈 */         .debug_str 0 : { *(.debug_str) }           /* .debug_str	字符串池	存储调试用的字符串 */             .debug_loc 0 : { *(.debug_loc) }           /* .debug_loc	变量位置表	告诉调试器变量在哪个寄存器/内存 */     .debug_macinfo 0 : { *(.debug_macinfo) }   /* .debug_macinfo	宏展开信息	用于显示宏定义的展开关系 */     .debug_ranges 0 : { *(.debug_ranges) }     /* .debug_ranges	地址范围	支持函数/块的多地址区间映射 */                                                                                          /* DWARF 2 control flow extension */  .debug_control_flow 0 : { *(.debug_control_flow) }  /* 少见, 用于保存编译器控制流图 */  /* SGI/MIPS DWARF 2 extensions */  .debug_weaknames 0 : { *(.debug_weaknames) }  /* 早期MIPS平台引入的DWARF扩展(HighTec保留兼容), 现代GCC基本用.debug_info替代这些功能 */  .debug_funcnames 0 : { *(.debug_funcnames) }  .debug_typenames 0 : { *(.debug_typenames) }  .debug_varnames 0 : { *(.debug_varnames) }  .version_info 0 : { *(.version_info) }  /* 保存编译器/链接器版本号、生成时间等元数据 */}