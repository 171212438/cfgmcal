/************************************************************************************************** * FILE: *     tc3x_crt0.S * ARCHITECTURE: *     TC3xx * UC FAMILY: *     All * DESCRIPTION: *     C/C++ runtime environment startup file. *     [Main duty] *     - To initialize ABI registers *     - To initialize CSA context area *     - To initialize Stack area needed for 'C' code *     - To initialize ECC in RAM memories (not done for AURIX) *     - To clear BSS (not-initialized) data *     - To initialize DATA (initialized) data *     - To initialize C++ global object instances *     - To provide startup hooks for user defined code *     [Multicore Startup] *     Crt0 startup on multicore systems is driven by a configuration provided *     by a corresponding linker file. Configuration table contains one entry *     for each Core present in uC *     [Startup Hooks] *     Crt0 provides two startup hooks the user can use to implement system dependent *     early HW initialization. *     1. 'Crt0PreInit()' hook called *        - after STACK area and CSA list on given core is initialized *        - before Clear and Copy table operation is executed *        ! HW initialization code cannot rely on global data (BSS or DATA) *     2. 'Crt0PostInit()' hook called *        - when all startup initialization is finished (data can be used) *        - before calling shared_main() application entry point *     [C++ support] *     The crt0 startup code provides a default global object initialization based on *     ctor table registered per core. *     The format of 'ctor' table expected: *     ctor_setion *     { *         __CTOR_LIST__ = .; *         LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2) *         KEEP (*(.ctors)); *         LONG(0); *         __CTOR_END__ = .; *     } *     By default, the linker gathers all C++ module ctor entries into one common ctor table. *     In case of multicore object initialization, the user must provide their system *     of CTOR initialization. *     [Application specific crt0 Routines Implementation] *     Startup routines are implemented as WEAK functions to allow application-specific *     replacement in case of need. *     - Crt0BssInit *     - Crt0DataInit *     - Crt0CtorInit *     - Crt0PreInit *     - Crt0PostInit * FILE HISTORY: *    V1  05.2020  RO *    - Base reference example *    V2  02.2021  RO *    - change in loading the values to address register %Ax from LD.A to LD.W, MOV.A sequence *      to avoid mandatory 4B alignment of LD.A instruction that might not be always guaranteed. *      The new sequence works with minimal 2B alignment, meaning no ALIGN restriction on data *      placement. ************************************************************************************************** * Copyright (C) 2015-2020 HighTec EDV-Systeme GmbH.  All rights reserved. * This is proprietary software. Any use of the software requires a written * license agreement with HighTec EDV-Systeme GmbH. Please contact for * detailed license information: info@hightec-rt.com. *************************************************************************************************//* ================================================================================================ * SYMBOLS & DEFINES & MACROS * ==============================================================================================*//* crt0_config : Entry offsets * Must correspond to __crt0_config structure defined in the Linker file */#define STACK               0x00#define STACK_SIZE          0x04#define CSA                 0x08#define CSA_SIZE            0x0C#define SDATA               0x10#define SDATA2              0x14#define SDATA3              0x18#define SDATA4              0x1C#define CLEAR_TABLE         0x20#define COPY_TABLE          0x24#define CTOR_TABLE          0x28#define CPUINIT_SIZE        0x2C  /* size of the init structure *//* CSA_ENTRY supportive symbols *     CSA_ENTRY_SIZE  : in bytes, given by TC3xx architecture *     LW_OFFSET_SHIFT : Link Word, low part shift offset */#define CSA_ENTRY_SIZE      64#define LW_OFFSET_SHIFT     -6/* CLEAR_TABLE structure offsets * Offsets must correspond to the Linker __clear_table structure * Offsets are in bytes * Structure *     1. LONG : DST  - Destaination base address *     2. LONG : SIZE - number of data to clear (write 0) in bytes */#define CLEAR_TABLE_DST     0x00#define CLEAR_TABLE_SIZE    0x04#define CLEAR_TABLE_OFFSET  0x08  /* Size of one entry in bytes *//* COPY_TABLE structure offsets * Offsets must correspond to the Linker __copy_table structure * Offsets are in bytes * Structure *     0. LONG : SRC  - Source address to copy data from *     1. LONG : DST  - Destaination address to copy data to *     2. LONG : SIZE - number of data to copy in bytes */#define COPY_TABLE_SRC      0x00#define COPY_TABLE_DST      0x04#define COPY_TABLE_SIZE     0x08#define COPY_TABLE_OFFSET   0x0C  /* Size of one entry in bytes *//* ================================================================================================ * EXTERNAL SYMBOLS REQUIRED BY CRT0 * ==============================================================================================*//* application shared main entry */.extern shared_main, STT_FUNC, 0/* crt0 config structure from linker */.extern __crt0_config, STT_OBJECT, 0/* ================================================================================================ * EXPORTED SYMBOLS FROM CRT0 * ==============================================================================================*//* _crt0_reset : reset entry point from where to start inactive cores */.global _crt0_reset.type _crt0_reset STT_FUNC/* _start : shared multicore crt0 startup code entry point */.global _start.type _start STT_FUNC/* ================================================================================================ * CRT0 RESET VECTOR * Here execution starts after the Reset. * The first duty is to force eventual address segment change in Aurix core * from non-cached memory to a cacheable one * ==============================================================================================*/   .section .crt0_boot.code, "ax"  /* 开一个节, 专门放启动汇编代码(CRT0各种初始化)", 并明确告诉工具:"这节是要加载到内存、且可执行的" */_crt0_reset:    movh.a  %a15, hi:_start           /* 把符号_start的高16位装进地址寄存器a15 */    lea     %a15, [%a15] lo:_start    /* 在a15的基础上, 再把_start的低16位加进去 */    ji      %a15                      /* 间接跳转到a15指向的地址, 也就是跳到_start *//* ================================================================================================ * CRT0 STARTUP CODE * A multicore shared code implementation of 'C' runtime intialization * located in a standard .text section that might be in cacheable region * ==============================================================================================*/   .section .text, "ax"_start:/* ------------------------------------------------------------------------------------------------ * CRT0 CONFIG TABLE BASE POINTER SETUP * Config table contains parameters controlling crt0 startup execution. * It is prepared by the linker file with the knowledge of the final placement. * Registers used by the crt0 startup code * 'A14` : is used as Core Entry Base Pointer in crt0 configuration structure *         throughout the statup asm code. * The A14 register value is saved by Aurix core in upper context during subroutine calls. * ----------------------------------------------------------------------------------------------*//* 我现在是core1? 那我去 __crt0_config + 1*CPUINIT_SIZE找我自己的初始化参数 */    movh.a  %a14, hi:__crt0_config    lea     %a14, [%a14]lo:__crt0_config   /* 拼出__crt0_config的绝对地址, 存进%a14, a14之后在整个启动过程中都会被当作配置表基址寄存器用 */    mfcr    %d15, $core_id                 /* 从系统寄存器里读当前核心编号 */                                           /* $core_id是编译器(汇编器)预定义的符号, 对应硬件寄存器地址0xFE1C */    and     %d15, 7                        /* 只保留最低3位 */    mul     %d15, %d15, CPUINIT_SIZE       /* 每个core的配置块大小固定(CPUINIT_SIZE), 乘上core_id就是该core的偏移量 */    addsc.a %a14, %a14, %d15, 0            /* 把偏移加到基址上, %a14就指向当前core的配置表入口 *//* ------------------------------------------------------------------------------------------------ * SMALL ADDRESS REGISTERS INIT * Values given by crt0 configuration structure from the linker file. * Four dedicated registers, if they are used * a0 - usually small data (rw) * a1 - usually small const data (r) * a8 - usually OS / application specific * a9 - usually OS / application specific * ----------------------------------------------------------------------------------------------*//* a0通常用于小数据区(rw), a1用于小常量区(ro) */    ld.w    %d15, [%a14] SDATA    /* 从配置表里读出SDATA区地址 */    mov.a   %a0, %d15             /* 把它装进寄存器a0 */    ld.w    %d15, [%a14] SDATA2    mov.a   %a1, %d15    ld.w    %d15, [%a14] SDATA3    mov.a   %a8, %d15    ld.w    %d15, [%a14] SDATA4    mov.a   %a9, %d15/* ------------------------------------------------------------------------------------------------ * CSA CONTEXT AREA INIT * Linked list initialization of CSA entries (TriCore specific feature) used to save * function context during standard 'C' function calls. * CSA entry and linked list has fixed structure given by AURIX architecture. * Number of CSA entries (max 256 entries) is part of crt0 configuration in the linker file. * ----------------------------------------------------------------------------------------------*//* CSA(Context Save Area, 上下文保存区)初始化 */    mov     %d4, 0    mtcr    $pcxi, %d4                 /* PCXI清零: 当前没有"上一层上下文" */    ld.w    %d4, [%a14] CSA_SIZE       /* 从crt0配置表读出CSA总大小(单位: 字节) */    sh      %d4, %d4, LW_OFFSET_SHIFT  /* 右移6位(64=2^6), 得到"记录个数" = SIZE/64 */    mov.a   %a4, %d4                   /* a4 = 循环计数(记录数) */    add.a   %a4, -1                    /* 计数-1, 为后续loop指令做准备 */    mov     %d4, CSA_ENTRY_SIZE        /* d4 = 64(每条记录大小) */    mov.a   %a3, %d4                   /* a3 = 64(后面用它给地址递增) */	  ld.w    %d4, [%a14] CSA            /* 从配置表读出CSA起始地址 */	  mov.a   %a15, %d4                  /* a15 = 当前正在处理的"这条记录"的地址(游标) */    movh    %d5, 0x000F                /* 先做个0x000Fxxxx的高半字, 给"段号"用 */    mov.d   %d15, %a15                 /* d15 = CSA基地址 */    sh      %d15, %d15, -12            /* 取地址高位做"段号"(TriCore链接字里有段字段) */    and     %d15, %d5                  /* d15 = 只保留段字段(其它位清掉) */    mov.u   %d5, 0xFFFF                /* d5 = 0x0000FFFF, 准备做"offset"掩码 */    mov.d   %d4, %a15                  /* d4 = CSA基地址(准备生成offset) */    sh      %d4, %d4, LW_OFFSET_SHIFT  /* 右移6位, 把地址换算成"以64B为单位的offset" */    and     %d4, %d5                   /* 只保留offset有效位 */    or      %d4, %d15                  /* d4 = 段字段 | offset字段  → 组合成Link Word */    mtcr    $fcx, %d4                  /* 把"第一条记录"的Link Word写进FCX(自由链表头) */loop_csa:    add     %d4, 1                     /* d4 = 下一个记录的Link Word值(offset+1) */    st.w    [%a15], %d4                /* 把它写到当前记录的Link Word(每条记录头4B) */    add.a   %a15, %a3                  /* a15指向下一条记录(地址 + 64) */    loop    %a4, loop_csa              /* 重复, 直到把配置表规定的记录数写完 */    mtcr    $lcx, %d4                  /* 记录最后一个Link Word到LCX(链表尾) *//* ------------------------------------------------------------------------------------------------ * STACK INIT * Mandatory operation before calling any 'C' function * Two things to do * 1. correct ECC checksum syndroms for complete Stack area by writing with required *    data size instructions * 2. Stack pointer init used by 'C' code * Startup code initialize both TriCore stack pointers, User and Interrupt, to the same area. * - the code runs with 'PSW.IS = 1' after the reset -> shared stack * - the separation of User and Interrupt stack is left on Application (usually OS) *   later on. * ----------------------------------------------------------------------------------------------*//* 堆栈初始化(STACK INIT): 在C函数跑起来前, 得先给它一块能放局部变量、返回地址、参数的内存 *//* 拿配置表里的Stack起点和大小 → 算出栈顶 → 把SP/ISP都设好 → 清理栈区 */    ld.w    %d4, [%a14] STACK    mov.a   %a4, %d4                /* 从配置表(由链接器生成)中读出堆栈底地址(通常是最低地址, 比如RAM起始). 把它存进寄存器a4, 作为堆栈区的起点 */    ld.w    %d4, [%a14] STACK_SIZE    mov.d   %d1, %a4    add     %d1, %d1, %d4           /* 从配置表再读出堆栈区大小(单位字节), 然后相加得到栈顶地址(高地址方向增长) */    mov.a   %sp, %d1    mtcr    $isp, %d1               /* 把算好的栈顶地址写入两个地方: %sp(寄存器a10)→ 用户栈; $isp → 中断栈寄存器, 此时两者都指向同一块共享区域 */    call    clear_exec              /* Call Clear routine *//* ------------------------------------------------------------------------------------------------ * CRT0 PRE-INIT 'C' USER CODE * Chance for user to execute HW init at the very beginning, before longer operations * take place, like memory clear and copy of init data from Flash to RAM. * In case of CORE dependent Hook execution, * the application must read it ourselves (physical CoreID might not correspond * to a consecutive sequence needed for array operations). * Pre-init code MUST rely only on Stack variables only ! * ----------------------------------------------------------------------------------------------*/    call    Crt0PreInit  /* Crt0PreInit()就是一个"早于一切"的钩子函数, 能在还没搬数据、没清BSS、没启动C库时, 就执行自己的硬件初始化代码 *//* ------------------------------------------------------------------------------------------------ * CLEAR .BSS SECTIONS * Areas to clear are given in the __clear_table config entry. * The crt0 function is of WEAK type to allow the user implementation in the application * by for example by 'C' specific routine * ----------------------------------------------------------------------------------------------*/    ld.w    %d4, [%a14] CLEAR_TABLE    mov.a   %a4, %d4    call    Crt0BssInit  /* 清理所有.bss段(未初始化的全局/静态变量) *//* ------------------------------------------------------------------------------------------------ * COPY INITIALIZED DATA * Initialization of data regions provided in __copy table in crt0 configuration structure. * The crt0 function is of WEAK type to allow the user implementation in the application. * ----------------------------------------------------------------------------------------------*/    ld.w    %d4, [%a14] COPY_TABLE    mov.a   %a4, %d4	call    Crt0DataInit  /* 把ROM/Flash中.data段的初始值复制到RAM *//* ------------------------------------------------------------------------------------------------ * C++ GLOBAL OBJECT INITIALIZATION * The ctor table (constructors to call) is provided as one of the crt0_configr structure entry. * Each core can have its own ctor table array, if implemented in the linker file * (not in BSP case) * ----------------------------------------------------------------------------------------------*/    ld.w    %d4, [%a14] CTOR_TABLE    mov.a   %a4, %d4    call    Crt0CtorInit  /* C++ 程序的"全局对象构造阶段" *//* ------------------------------------------------------------------------------------------------ * CRT0 POST-INIT 'C' USER CODE * Chance for user to execute specific code before jump to application entry, * 'shared main()' in case of BSP * In case of core dependent Hook execution, * the application must read it ourselves (physical CoreID might not correspond * to a consecutive sequence needed for array operations). * ----------------------------------------------------------------------------------------------*//* 非常适合:设置中断向量表;打开外设时钟;初始化调试串口;启动FreeRTOS等 */    call    Crt0PostInit  /* 用户自定义的"主程序启动前最后机会"钩子 */ /* ----------------------------------------------------------------------------------------------- * CRT0 END : ENTRY TO APPLICATION * Jump to the application entry point, shared across all cores in case of BSP examples * In case of core dependent Hook execution, the application must read it ourselves, * physical CoreID might not correspond to a consecutive sequence needed for array operations * The return from the application is not expected, hard to say what the embedded system * shall do here * ----------------------------------------------------------------------------------------------*/    call    shared_main_exit:  /* 程序"无路可走"时的停机处理 */    debug  /* 如果MCU连接着调试器(比如PLS UDE、Lauterbach、iSYSTEM等), 执行debug会触发调试中断(Debug Trap),CPU会停住, 让调试器抓住执行点, 相当于一个内嵌的断点 */           /* 如果MCU没有在调试状态下运行(比如量产代码直接上电启动), debug会被当成空操作(nop)执行, 不会影响程序 */    j .    /* 让程序卡在自己原地跑, 不再向下执行, 死循环等看门狗超时复位 *//* ================================================================================================ * CRT0 'DEFAULT' FUNCTIONS * Implemented as WEAK to allow their replacement by the user versions in the application * ==============================================================================================*//* ------------------------------------------------------------------------------------------------ * FUNCTION: Crt0PreInit * User hook before 'C' runtime initialization. Empty routine in case of crt0 startup code. * ----------------------------------------------------------------------------------------------*/    .weak Crt0PreInit    .type Crt0PreInit, %functionCrt0PreInit:    ret/* ------------------------------------------------------------------------------------------------ * FUNCTION: Crt0PostInit * User hook after 'C' runtime initialization. Empty routine in case of crt0 startup code. * ----------------------------------------------------------------------------------------------*/    .weak Crt0PostInit   .type Crt0PostInit, %functionCrt0PostInit:    ret/* ------------------------------------------------------------------------------------------------ * FUNCTION: Crt0BssInit * Default Crt0 BSS clear function. It goes through clear_table entries and calls the clear * operation for each of them * Input * A[4] : core's clear_table base pointer * ----------------------------------------------------------------------------------------------*//* 弱定义的特点: * 如果程序里没有别的强定义(strong symbol), 那就用这一份; * 如果用户自己定义了同名函数(例如在别的C文件中void Crt0BssInit(void)),链接器会自动替换掉这个弱的版本, 链接时不会报重复定义错误 *//* 清零.bss段(静态分配但未赋初值的变量空间), 把所有未初始化的全局/静态变量全部清成0 */    .weak Crt0BssInit  /* 定义了一个名字叫Crt0BssInit的符号, 但它是弱定义(weak definition) */   .type Crt0BssInit, %function  /* 符号Crt0BssInit是一个函数, 而不是数据变量 */Crt0BssInit:    mov.aa  %a13, %a4    mov.a   %a12, CLEAR_TABLE_OFFSET             /* %a4是当前core的clear_table基址(由前面传入); %a13用作表项指针; %a12存放每条表项的步进大小(即offset) */_table_bss_clear_loop:    ld.w    %d15, [%a13] CLEAR_TABLE_DST    jeq     %d15, -1, _table_bss_clear_loop_end  /* 读取当前表项的目标地址(要清零的区域起点); 如果等于 -1, 说明到表尾了, 跳出循环 */    mov.a   %a4, %d15    ld.w    %d4, [%a13] CLEAR_TABLE_SIZE         /* 把目标地址存到%a4, 作为clear_exec()的起始地址; 再读出当前区域的大小, 存到%d4 */    call    clear_exec                           /* Call Clear routine with saving Upper Context */    add.a   %a13,%a12    j       _table_bss_clear_loop                /* 表指针前进一行(下一个表项), 继续处理; 重复直到遇到-1结束标志 */_table_bss_clear_loop_end:    ret/* ------------------------------------------------------------------------------------------------ * FUNCTION: Crt0DataInit * Default Crt0 DATA init function. It goes through copy_table entries and calls * copy operation for each of them. * Input * A[4] : core's copy_table pointer * ----------------------------------------------------------------------------------------------*/    .weak Crt0DataInit   .type Crt0DataInit, %functionCrt0DataInit:    mov.aa  %a13, %a4    mov.a   %a12, COPY_TABLE_OFFSET              /* %a4是输入参数(当前core的copy_table起始地址); %a13用作当前遍历的表指针; %a12保存表项的步进长度(即一行结构体大小) */_table_data_copy_loop:    ld.w    %d15, [%a13]COPY_TABLE_DST    jeq     %d15, -1, _table_data_copy_loop_end  /* 从表中读取"目的地址"(即要写入的RAM地址); 如果等于 -1, 说明到表尾, 跳出循环 */    mov.a   %a4, %d15    ld.w    %d4, [%a13]COPY_TABLE_SRC    mov.a   %a5, %d4    ld.w    %d4, [%a13]COPY_TABLE_SIZE    call    copy_exec                            /* %a4: 目标地址(RAM); %a5: 源地址(Flash); %d4: 拷贝字节数, 然后调用copy_exec完成具体的memcpy操作 */    add.a   %a13, %a12                           /* 表指针加一个偏移, 进入下一条表项 */    j       _table_data_copy_loop                /* 继续循环直到遇到结束标志 */_table_data_copy_loop_end:    ret/* ------------------------------------------------------------------------------------------------ * FUNCTION: Crt0CtorInit * Default global C++ object initialization. It goes through ctor table and calls * global constructors. * Input * A[4] : CTOR table base address * ----------------------------------------------------------------------------------------------*//* 全局C++ 对象构造函数的自动执行 */    .weak Crt0CtorInit   .type Crt0CtorInit, %functionCrt0CtorInit:    jz.a    %a4, _ctor_exec_end    /* 检查输入参数%a4是否为0 */    ld.w    %d4, [%a4+]4           /* 从CTOR表里读出"函数数量"; */    mov.a   %a15, %d4              /* 存入 %a15作为循环计数; */    jz.a    %a15, _ctor_exec_end   /* 若数量为0, 则直接退出; */    add.a   %a15, -1               /* 因为loop指令默认多执行一次, 所以计数 -1 */_ctor_exec_loop:    ld.w    %d4, [%a4+]4           /* 取出当前表项中的函数指针; */    mov.a   %a13, %d4              /* 放入地址寄存器; */    calli   %a13                   /* 间接调用(执行该构造函数); */    loop    %a15, _ctor_exec_loop  /* 硬件循环, 直到所有构造函数执行完 */_ctor_exec_end:	ret/* ================================================================================================ * MODULE LOCAL ROUTINES * Used only within this module * ==============================================================================================*//* ------------------------------------------------------------------------------------------------ * FUNCTION: clear_exec * Executes the erase loop from start address for specified number of bytes. * It uses 64bit Store instruction * Input * A[4] : start address * D[4] : size in bytes * ----------------------------------------------------------------------------------------------*/clear_exec:    jz      %d4,_clear_exec_end    /* 如果大小为0, 就直接返回. 没必要清空 */    add     %d4,-1                 /* 后面会用loop指令做倒计数循环,TriCore的loop计数是"执行N+1次", 所以这里先减1, 保证准确执行次数 */    sh      %d4,-3                 /* 移3位(除以8), 因为每次清8个字节(64bit) */    mov.a   %a15,%d4               /* 把循环次数存入a15寄存器, 作为loop控制计数器 */    mov     %e14,0                 /* 准备好要写入的"0值",TriCore的 %e14是偶寄存器对(d14:d15), 可以一次存64位 */_clear_exec_loop:    st.d    [%a4+]8,%e14           /* 向地址 %a4写入 %e14的64位数据(两个32位寄存器合成的双字). 然后 %a4自增8(下一个8字节位置) */    loop    %a15,_clear_exec_loop  /* 执行一次body; 递减a15; 如果不为0, 自动跳回 _clear_exec_loop */_clear_exec_end:    ret                            /* 清完后返回 *//* ------------------------------------------------------------------------------------------------ * FUNCTION: copy_exec * Executes the copy loop from start address to end address. * Routine is simple Byte copy without any optimization. * Input * A[4] : start write address * A[5] : start read address * D[4] : size in bytes * ----------------------------------------------------------------------------------------------*//* 纯字节拷贝循环 */copy_exec:    mov     %d15, %d4              /* 把size拷贝到 %d15备用.TriCore的loop指令需要一个计数寄存器 */    jz      %d15, _copy_exec_end   /* 如果大小为0, 直接返回. 避免陷入无意义的循环 */    add     %d15, -1               /* loop指令在计数为0时会多执行一次循环, 所以要先减1 */    mov.a   %a15, %d15             /* 把计数值放进地址寄存器a15, 作为loop的计数器 */_copy_exec_loop:    ld.b    %d15, [%a5+]1          /* 从源地址 %a5读一个字节到 %d15, 地址自增1 */    st.b    [%a4+]1, %d15          /* 把 %d15写到目标地址 %a4, 地址自增1 */    loop    %a15, _copy_exec_loop  /* 硬件循环, 自动递减计数, 直到拷完所有字节 */_copy_exec_end:    ret