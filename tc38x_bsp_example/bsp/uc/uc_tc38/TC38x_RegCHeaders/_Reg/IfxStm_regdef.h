

/**
* file IfxStm_regdef.h

* copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
* Version: TC38XA_UM_V1.5.0.R0
* Specification: TC3xx User Manual V1.5.0
* MAY BE CHANGED BY USER [yes/no]: No
*                                 IMPORTANT NOTICE
* Use of this file is subject to the terms of use agreed between (i) you or 
* the company in which ordinary course of business you are acting and (ii) 
* Infineon Technologies AG or its licensees. If and as long as no such 
* terms of use are agreed, use of this file is subject to following:

* Boost Software License - Version 1.0 - August 17th, 2003

* Permission is hereby granted, free of charge, to any person or 
* organization obtaining a copy of the software and accompanying 
* documentation covered by this license (the "Software") to use, reproduce,
* display, distribute, execute, and transmit the Software, and to prepare
* derivative works of the Software, and to permit third-parties to whom the 
* Software is furnished to do so, all subject to the following:

* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer, must
* be included in all copies of the Software, in whole or in part, and all
* derivative works of the Software, unless such copies or derivative works are
* solely in the form of machine-executable object code generated by a source
* language processor.

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
* defgroup IfxSfr_Stm_Registers Stm Registers
* ingroup IfxSfr
* 
* defgroup IfxSfr_Stm_Registers_Bitfields Bitfields
* ingroup IfxSfr_Stm_Registers
* 
* defgroup IfxSfr_Stm_Registers_union Register unions
* ingroup IfxSfr_Stm_Registers
* 
* defgroup IfxSfr_Stm_Registers_struct Memory map
* ingroup IfxSfr_Stm_Registers */
#ifndef IFXSTM_REGDEF_H
#define IFXSTM_REGDEF_H 1

/******************************************************************************/
#include "Ifx_TypesReg.h"

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/* STM的"访问白名单". EN0.. EN31每一位对应一类总线主设备(Master TAG ID). 某位设成1, 即允许对应主设备访问STM寄存器; 设成0, 就禁止它访问(读写都会被拦)
 *   为什么需要它: 做隔离. 比如FuSa项目里, 只让CPU0/CPU1能读STM, 当别的核、DMA、HSM等"主设备"误访问时直接被硬件挡住, 避免跨域干扰;
 *   哪些是"主设备": 由SoC的TAG ID映射表决定(每个CPU、DMA、外设总线主机都有固定ID). ENi就是"ID=i的主设备能否碰STM". 具体编号在芯片文档的master-TAG表里;
 *   默认值: 芯片复位默认通常放开多数访问(厂商方便开发调试). 安全设计里应当只开必要的位;
 *   改这个寄存器需要权限: 这是安全域(Safety)受保护寄存器, 修改前通常要走Safety Endinit解锁, 写完再上锁;
 *   和CLC无关: ACCENx控制"谁能碰"; CLC控制"有没有钟". 两个维度互不替代; */
/* Access Enable Register 0 */
typedef struct _Ifx_STM_ACCEN0_Bits {
  Ifx_UReg_32Bit EN0 : 1;   /* [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
  Ifx_UReg_32Bit EN1 : 1;   /* [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
  Ifx_UReg_32Bit EN2 : 1;   /* [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
  Ifx_UReg_32Bit EN3 : 1;   /* [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
  Ifx_UReg_32Bit EN4 : 1;   /* [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
  Ifx_UReg_32Bit EN5 : 1;   /* [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
  Ifx_UReg_32Bit EN6 : 1;   /* [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
  Ifx_UReg_32Bit EN7 : 1;   /* [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
  Ifx_UReg_32Bit EN8 : 1;   /* [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
  Ifx_UReg_32Bit EN9 : 1;   /* [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
  Ifx_UReg_32Bit EN10 : 1;  /* [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
  Ifx_UReg_32Bit EN11 : 1;  /* [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
  Ifx_UReg_32Bit EN12 : 1;  /* [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
  Ifx_UReg_32Bit EN13 : 1;  /* [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
  Ifx_UReg_32Bit EN14 : 1;  /* [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
  Ifx_UReg_32Bit EN15 : 1;  /* [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
  Ifx_UReg_32Bit EN16 : 1;  /* [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
  Ifx_UReg_32Bit EN17 : 1;  /* [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
  Ifx_UReg_32Bit EN18 : 1;  /* [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
  Ifx_UReg_32Bit EN19 : 1;  /* [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
  Ifx_UReg_32Bit EN20 : 1;  /* [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
  Ifx_UReg_32Bit EN21 : 1;  /* [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
  Ifx_UReg_32Bit EN22 : 1;  /* [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
  Ifx_UReg_32Bit EN23 : 1;  /* [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
  Ifx_UReg_32Bit EN24 : 1;  /* [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
  Ifx_UReg_32Bit EN25 : 1;  /* [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
  Ifx_UReg_32Bit EN26 : 1;  /* [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
  Ifx_UReg_32Bit EN27 : 1;  /* [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
  Ifx_UReg_32Bit EN28 : 1;  /* [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
  Ifx_UReg_32Bit EN29 : 1;  /* [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
  Ifx_UReg_32Bit EN30 : 1;  /* [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
  Ifx_UReg_32Bit EN31 : 1;  /* [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_STM_ACCEN0_Bits;
/* Access Enable Register 1 没有用到 */
typedef struct _Ifx_STM_ACCEN1_Bits {
  Ifx_UReg_32Bit reserved_0 : 32;    /* [31:0] internal Reserved */
} Ifx_STM_ACCEN1_Bits;


/* 当CCUCON0.STMDIV = 0(STM被禁)时, 不要访问STM寄存器(除CLC外), 否则可能收到总线重试/异常; 先恢复分频再读写;
 * 读一次低位就会更新一次拍照值; 如果要两次测量之间的差值, 确保两次都用同一种配对流程, 保持一致性; */
/* Timer Capture Register */
typedef struct _Ifx_STM_CAP_Bits {
  Ifx_UReg_32Bit STMCAP_63_32 : 32;  /* [31:0] 当读TIM0时, 硬件把那一刻的高32位锁进CAP. 随后读CAP, 就能和刚才的低32位拼成一致的64位时间戳. 这是TIM0的配套拍照窗 (rh-读保持寄存器) */
} Ifx_STM_CAP_Bits;
/* Timer Capture Register Second View */
typedef struct _Ifx_STM_CAPSV_Bits {
  Ifx_UReg_32Bit STMCAP_63_32 : 32;  /* [31:0] 当读TIM0SV(TIM0的第二地址视图)时, 硬件把高32位锁进CAPSV. 这是TIM0SV的配套拍照窗. 用法同上, 只是配对对象不同 (rh) */
} Ifx_STM_CAPSV_Bits;


/* Clock Control Register */
/* 注意: 模块被关掉时, 除了CLC, 不要访问别的寄存器——可能报总线错;
 * 启用STM(上电后一般本就启用, 这里给规范流程):
 *   关安全保护(Safety Endinit)→ 写CLC: DISR=0, EDIS按需设0/1 → 开保护;
 *   轮询DISS==0, 确认时钟真的开了;
 * 停用STM:
 *   关Endinit → 写DISR=1(EDIS随需求)→ 开Endinit;
 *   轮询DISS==1, 确认已停;
 * Sleep行为设置:
 *   想让STM随系统Sleep一起停: EDIS=0;
 *   想让STM睡觉也不停(比如用它当唤醒/时基): EDIS=1; */
typedef struct _Ifx_STM_CLC_Bits {
	Ifx_UReg_32Bit DISR : 1;				 /* [0:0] 写0: 请求开时钟(让STM工作); 写1: 请求关时钟(让STM停) (rw) */
	Ifx_UReg_32Bit DISS : 1;				 /* [1:1] 读0: 在跑(有时钟); 读1: 已停(无时钟) (r) */
	Ifx_UReg_32Bit reserved_2 : 1;	 /* [2:2] internal Reserved */
	Ifx_UReg_32Bit EDIS : 1;				 /* [3:3] 写0: 响应Sleep请求, 进Sleep时不工作; 写1: 不理会, 进Sleep仍工作 (rw) */
	Ifx_UReg_32Bit reserved_4 : 28;  /* [31:4] internal Reserved */
} Ifx_STM_CLC_Bits;


/* Compare Match Control Register STM的比较匹配控制寄存器CMCON */
/* 把STM[MSTART+MSIZE:MSTART]和(CMPx[MSIZE:0]右补零)做相等判断; 相等就产生该比较器的匹配事件.
 * 这一机制既能做"位翻转检测"(MSIZE=0)、也能做"32位窗口匹配"(MSIZE=31, MSTART=0);
 * 当CCUCON0.STMDIV=0时禁止访问, 会被从属接口以RTY/重试响应 */
typedef struct _Ifx_STM_CMCON_Bits {
	Ifx_UReg_32Bit MSIZE0 : 5;			 /* [4:0] 比较宽度. 值0…31表示"用CMPx的低MSIZEx+1位参与比较" (rw) */
	Ifx_UReg_32Bit reserved_5 : 3;	 /* [7:5] internal Reserved */
	Ifx_UReg_32Bit MSTART0 : 5; 		 /* [12:8] 比较起始位. 值0…31表示"从STM的bit[n]开始, 向上取MSIZEx+1位来比" (rw) */
	Ifx_UReg_32Bit reserved_13 : 3;  /* [15:13] internal Reserved */
	Ifx_UReg_32Bit MSIZE1 : 5;			 /* [20:16] 比较宽度. 值0…31表示"用CMPx的低MSIZEx+1位参与比较" (rw) */
	Ifx_UReg_32Bit reserved_21 : 3;  /* [23:21] internal Reserved */
	Ifx_UReg_32Bit MSTART1 : 5; 		 /* [28:24] 比较起始位. 值0…31表示"从STM的bit[n]开始, 向上取MSIZEx+1位来比" (rw) */
	Ifx_UReg_32Bit reserved_29 : 3;  /* [31:29] internal Reserved */
} Ifx_STM_CMCON_Bits;


/* Compare Register ${x} */
typedef struct _Ifx_STM_CMP_Bits {
  Ifx_UReg_32Bit CMPVAL : 32;  /* [31:0] CMPx就是STM比较器用来"对齐时间点"的目标值 (rw) */
} Ifx_STM_CMP_Bits;


/* Interrupt Control Register
 * STM的中断开关与路由器, 一手管使能, 一手看是否请求, 还决定把中断抛到哪根SR线(SRC里再设优先级/目标核) */
typedef struct _Ifx_STM_ICR_Bits {
	Ifx_UReg_32Bit CMP0EN : 1;			 /* [0:0] 对应比较器中断使能 (rw) */
	Ifx_UReg_32Bit CMP0IR : 1;			 /* [1:1] 中断请求标志(只读保持) (rh) */
	Ifx_UReg_32Bit CMP0OS : 1;			 /* [2:2] 输出选择(把该比较器的请求接到哪一路SR) (rw) */
	Ifx_UReg_32Bit reserved_3 : 1;	 /* [3:3] internal Reserved */
	Ifx_UReg_32Bit CMP1EN : 1;			 /* [4:4] 对应比较器中断使能 (rw) */
	Ifx_UReg_32Bit CMP1IR : 1;			 /* [5:5] 中断请求标志(只读保持) (rh) */
	Ifx_UReg_32Bit CMP1OS : 1;			 /* [6:6] 输出选择(把该比较器的请求接到哪一路SR) (rw) */
	Ifx_UReg_32Bit reserved_7 : 25;  /* [31:7] internal Reserved */
} Ifx_STM_ICR_Bits;


/* Module Identification Register
 * STM的模块身份证(ID寄存器), 只读, 用来告知"我是谁、哪个版本" */
typedef struct _Ifx_STM_ID_Bits {
  Ifx_UReg_32Bit MODREV : 8;   /* [7:0] 模块修订号, 硬件IP的版本号, 从0x01起递增 (r) */
  Ifx_UReg_32Bit MODTYPE : 8;  /* [15:8] 模块类型标记, 固定0xC0, 表示"32-bit模块类型" (r) */
  Ifx_UReg_32Bit MODNUM : 16;  /* [31:16] 模块编号, 用来区分是哪类外设, STM的编号固定为0x0068 (r) */
} Ifx_STM_ID_Bits;


/* Interrupt Set/Clear Register
 * STM比较中断标志的"软件置位/清位器". ICR只管"开关和路由", 真正的清标志/造标志都在ISCR */
typedef struct _Ifx_STM_ISCR_Bits {
  Ifx_UReg_32Bit CMP0IRR : 1;  /* [0:0] 写1清除对应比较器的中断请求标志(ICR里的CMPxIR) (w) */
  Ifx_UReg_32Bit CMP0IRS : 1;  /* [1:1] 写1置位对应比较器的中断请求标志(等价于"软件触发一次匹配") (w) */
  Ifx_UReg_32Bit CMP1IRR : 1;  /* [2:2] Reset Compare Register CMP1 Interrupt Flag - CMP1IRR (w) */
  Ifx_UReg_32Bit CMP1IRS : 1;  /* [3:3] Set Compare Register CMP1 Interrupt Flag - CMP1IRS (w) */
  Ifx_UReg_32Bit reserved_4 : 28;  /* [31:4] internal Reserved */
} Ifx_STM_ISCR_Bits;


/* Kernel Reset Register 0 */
typedef struct _Ifx_STM_KRST0_Bits {
	Ifx_UReg_32Bit RST : 1; 				 /* [0:0] 写1: 第二把开关——执行复位. 只有KRST1.RST=1之后再写KRST0. RST=1, 模块才会真的进复位. 双钥匙, 防误触; (rwh) */
	Ifx_UReg_32Bit RSTSTAT : 1; 		 /* [1:1] 读: 复位状态锁存. 当模块被内核复位过, 这个位会变成1, 提示"我刚复位过, 还没被清除状态"; (rh) */
	Ifx_UReg_32Bit reserved_2 : 30;  /* [31:2] internal Reserved */
} Ifx_STM_KRST0_Bits;
/* Kernel Reset Register 1 */
typedef struct _Ifx_STM_KRST1_Bits {
  Ifx_UReg_32Bit RST : 1;          /* [0:0] 写1: 第一把开关——预备复位; (rwh) */
  Ifx_UReg_32Bit reserved_1 : 31;  /* [31:1] internal Reserved */
} Ifx_STM_KRST1_Bits;
/* Kernel Reset Status Clear Register */
typedef struct _Ifx_STM_KRSTCLR_Bits {
  Ifx_UReg_32Bit CLR : 1;          /* [0:0] 写1: 清除复位状态并释放. 写1清RSTSTAT, 把模块从"复位保持/状态挂起"里完全释放出来; (w) */
  Ifx_UReg_32Bit reserved_1 : 31;  /* [31:1] internal Reserved */
} Ifx_STM_KRSTCLR_Bits;


/* OCDS Control and Status Register
 * STM的调试挂起控制寄存器(OCS). 配合调试器/OCDS用来"单步时要不要让STM跟着停" */
typedef struct _Ifx_STM_OCS_Bits {
	Ifx_UReg_32Bit reserved_0 : 3;	 /* [2:0] internal Reserved */
	Ifx_UReg_32Bit reserved_3 : 21;  /* [23:3] internal Reserved */
	Ifx_UReg_32Bit SUS : 4; 				 /* [27:24] 0x0: 不挂起(调试停CPU, STM仍在跑); 0x2: 软挂起STM ——64位计数器停止(读写寄存器仍可进行); (rw) */
	Ifx_UReg_32Bit SUS_P : 1; 			 /* [28:28] 写OCS时, 必须在同一次32位写入里把SUS_P=1一起写上, SUS字段才会被更新; 读它永远是0 (w) */
	Ifx_UReg_32Bit SUSSTA : 1;			 /* [29:29] 0没挂起; 1已挂起(调试系统把挂起信号送到模块, 且模块按SUS执行了停/不停) (rh) */
	Ifx_UReg_32Bit reserved_30 : 2;  /* [31:30] internal Reserved */
} Ifx_STM_OCS_Bits;


/* 读取任意一个TIM0.. TIM6或TIM0SV时, 硬件会把当下的高32位锁存到CAP(捕获寄存器). 这样可以拿到同一时刻的上下32位, 避免"先读低位、再读高位时正好进位"导致的撕裂
 * 需要高精度(比如微秒级tick): 用TIM0/TIM0SV;
 * 需要长时间范围(比如秒级超时但不想处理32位溢出): 用TIM4/5/6这类"更高位"的窗口做差
 * fSTM来自CCUCON0. STMDIV的分频设置: STMDIV=0表示停钟; STMDIV=n时fSTM = fsource0/n(部分值保留不用). 所以每个计数 = 1/fSTM秒. 例如fsource0=200 MHz, STMDIV=20 → fSTM=10 MHz → 1 tick=0. 1 µs
 * 停钟期间别碰STM: 当CCUCON0. STMDIV=0时访问STM, 外设会返回重试/总线异常; 先恢复分频再读写(CLC除外);
 * 应用复位行为: 是否在Application Reset下清零由SCU_ARSTDIS. STMxDIS决定; 清零后比较中断标志的初始值要按流程清理/重配 */
/* Timer Register 0 */
typedef struct _Ifx_STM_TIM0_Bits {
  Ifx_UReg_32Bit STM_31_0 : 32;  /* [31:0] 最低32位, 高分辨率、溢出最快. TIM0SV是TIM0的第二地址(内容一样) - STM[31:0] (r) */
} Ifx_STM_TIM0_Bits;
/* Timer Register 0 Second View */
typedef struct _Ifx_STM_TIM0SV_Bits {
  Ifx_UReg_32Bit STM_31_0 : 32;  /* [31:0] 第二地址视图方便做"无撕裂"读取 - STM[31:0] (r) */
} Ifx_STM_TIM0SV_Bits;
/* TIM1~TIM5: 把64位计数器右移后取32位的"窗口" */
/* Timer Register 1 */
typedef struct _Ifx_STM_TIM1_Bits {
  Ifx_UReg_32Bit STM_35_4 : 32;  /* [31:0] System Timer Bits [35:4] - STM[35:4] (r) */
} Ifx_STM_TIM1_Bits;
/* Timer Register 2 */
typedef struct _Ifx_STM_TIM2_Bits {
  Ifx_UReg_32Bit STM_39_8 : 32;  /* [31:0] System Timer Bits [39:8] - STM[39:8] (r) */
} Ifx_STM_TIM2_Bits;
/* Timer Register 3 */
typedef struct _Ifx_STM_TIM3_Bits {
  Ifx_UReg_32Bit STM_43_12 : 32;  /* [31:0] System Timer Bits [43:12] - STM[43:12] (r) */
} Ifx_STM_TIM3_Bits;
/* Timer Register 4 */
typedef struct _Ifx_STM_TIM4_Bits {
  Ifx_UReg_32Bit STM_47_16 : 32;  /* [31:0] System Timer Bits [47:16] - STM[47:16] (r) */
} Ifx_STM_TIM4_Bits;
/* Timer Register 5 */
typedef struct _Ifx_STM_TIM5_Bits {
  Ifx_UReg_32Bit STM_51_20 : 32;  /* [31:0] System Timer Bits [51:20] - STM[51:20] (r) */
} Ifx_STM_TIM5_Bits;
/* Timer Register 6 */
typedef struct _Ifx_STM_TIM6_Bits {
  Ifx_UReg_32Bit STM_63_32 : 32;  /* [31:0] 高32位窗口 - STM[63:32] (r) */
} Ifx_STM_TIM6_Bits;


/******************************************************************************/
/******************************************************************************/
/* addtogroup IfxSfr_stm_Registers_union */
/* Access Enable Register 0 */
typedef union {
  Ifx_UReg_32Bit U;       /* Unsigned access */
  Ifx_SReg_32Bit I;       /* Signed access */
  Ifx_STM_ACCEN0_Bits B;  /* Bitfield access */
} Ifx_STM_ACCEN0;


/* Access Enable Register 1 */
typedef union {
  Ifx_UReg_32Bit U;       /* Unsigned access */
  Ifx_SReg_32Bit I;       /* Signed access */
  Ifx_STM_ACCEN1_Bits B;  /* Bitfield access */
} Ifx_STM_ACCEN1;


/* Timer Capture Register */
typedef union {
  Ifx_UReg_32Bit U;       /* Unsigned access */
  Ifx_SReg_32Bit I;       /* Signed access */
  Ifx_STM_CAP_Bits B;     /* Bitfield access */
} Ifx_STM_CAP;


/* Timer Capture Register Second View */
typedef union {
  Ifx_UReg_32Bit U;      /* Unsigned access */
  Ifx_SReg_32Bit I;      /* Signed access */
  Ifx_STM_CAPSV_Bits B;  /* Bitfield access */
} Ifx_STM_CAPSV;


/* Clock Control Register */
typedef union {
  Ifx_UReg_32Bit U;      /* Unsigned access */
  Ifx_SReg_32Bit I;      /* Signed access */
  Ifx_STM_CLC_Bits B;    /* Bitfield access */
} Ifx_STM_CLC;


/* Compare Match Control Register */
typedef union {
  Ifx_UReg_32Bit U;      /* Unsigned access */
  Ifx_SReg_32Bit I;      /* Signed access */
  Ifx_STM_CMCON_Bits B;  /* Bitfield access */
} Ifx_STM_CMCON;


/* Compare Register ${x} */
typedef union {
  Ifx_UReg_32Bit U;      /* Unsigned access */
  Ifx_SReg_32Bit I;      /* Signed access */
  Ifx_STM_CMP_Bits B;    /* Bitfield access */
} Ifx_STM_CMP;


/* Interrupt Control Register */
typedef union {
  Ifx_UReg_32Bit U;      /* Unsigned access */
  Ifx_SReg_32Bit I;      /* Signed access */
  Ifx_STM_ICR_Bits B;    /* Bitfield access */
} Ifx_STM_ICR;


/* Module Identification Register */
typedef union {
  Ifx_UReg_32Bit U;      /* Unsigned access */
  Ifx_SReg_32Bit I;      /* Signed access */
  Ifx_STM_ID_Bits B;     /* Bitfield access */
} Ifx_STM_ID;


/* Interrupt Set/Clear Register */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_ISCR_Bits B;     /* Bitfield access */
} Ifx_STM_ISCR;


/* Kernel Reset Register 0 */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_KRST0_Bits B;    /* Bitfield access */
} Ifx_STM_KRST0;


/* Kernel Reset Register 1 */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_KRST1_Bits B;    /* Bitfield access */
} Ifx_STM_KRST1;


/* Kernel Reset Status Clear Register */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_KRSTCLR_Bits B;  /* Bitfield access */
} Ifx_STM_KRSTCLR;


/* OCDS Control and Status Register */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_OCS_Bits B;      /* Bitfield access */
} Ifx_STM_OCS;


/* Timer Register 0 */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_TIM0_Bits B;     /* Bitfield access */
} Ifx_STM_TIM0;


/* Timer Register 0 Second View */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_TIM0SV_Bits B;   /* Bitfield access */
} Ifx_STM_TIM0SV;


/* Timer Register 1 */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_TIM1_Bits B;     /* Bitfield access */
} Ifx_STM_TIM1;


/* Timer Register 2 */
typedef union {
  Ifx_UReg_32Bit U;        /* Unsigned access */
  Ifx_SReg_32Bit I;        /* Signed access */
  Ifx_STM_TIM2_Bits B;     /* Bitfield access */
} Ifx_STM_TIM2;


/* Timer Register 3 */
typedef union {
  Ifx_UReg_32Bit U;     /* Unsigned access */
  Ifx_SReg_32Bit I;     /* Signed access */
  Ifx_STM_TIM3_Bits B;  /* Bitfield access */
} Ifx_STM_TIM3;


/* Timer Register 4 */
typedef union {
  Ifx_UReg_32Bit U;     /* Unsigned access */
  Ifx_SReg_32Bit I;     /* Signed access */
  Ifx_STM_TIM4_Bits B;  /* Bitfield access */
} Ifx_STM_TIM4;


/* Timer Register 5 */
typedef union {
  Ifx_UReg_32Bit U;     /* Unsigned access */
  Ifx_SReg_32Bit I;     /* Signed access */
  Ifx_STM_TIM5_Bits B;  /* Bitfield access */
} Ifx_STM_TIM5;


/* Timer Register 6 */
typedef union {
  Ifx_UReg_32Bit U;     /* Unsigned access */
  Ifx_SReg_32Bit I;     /* Signed access */
  Ifx_STM_TIM6_Bits B;  /* Bitfield access */
} Ifx_STM_TIM6;


/******************************************************************************
 * addtogroup IfxSfr_Stm_Registers_struct
 ******************************************************************************/
/* STM object */
typedef volatile struct _Ifx_STM
{
	Ifx_STM_CLC CLC;								 /* 0, Clock Control Register */
	Ifx_UReg_8Bit reserved_4[4];		 /* 4, internal Reserved */
	Ifx_STM_ID ID;									 /* 8, Module Identification Register */
	Ifx_UReg_8Bit reserved_C[4];		 /* C, internal Reserved */
	Ifx_STM_TIM0 TIM0;							 /* 10, 把64位STM系统定时器按不同"窗口"切成7个只读的32位"快照" */
	Ifx_STM_TIM1 TIM1;							 /* 14, Timer Register 1 */
	Ifx_STM_TIM2 TIM2;							 /* 18, Timer Register 2 */
	Ifx_STM_TIM3 TIM3;							 /* 1C, Timer Register 3 */
	Ifx_STM_TIM4 TIM4;							 /* 20, Timer Register 4 */
	Ifx_STM_TIM5 TIM5;							 /* 24, Timer Register 5 */
	Ifx_STM_TIM6 TIM6;							 /* 28, Timer Register 6 */
	Ifx_STM_CAP CAP;								 /* 2C, Timer Capture Register */
	Ifx_STM_CMP CMP[2]; 						 /* 30, Compare Register ${x} */
	Ifx_STM_CMCON CMCON;						 /* 38, Compare Match Control Register */
	Ifx_STM_ICR ICR;								 /* 3C, Interrupt Control Register */
	Ifx_STM_ISCR ISCR;							 /* 40, Interrupt Set/Clear Register */
	Ifx_UReg_8Bit reserved_44[12];	 /* 44, internal Reserved */
	Ifx_STM_TIM0SV TIM0SV;					 /* 50, Timer Register 0 Second View */
	Ifx_STM_CAPSV CAPSV;						 /* 54, Timer Capture Register Second View */
	Ifx_UReg_8Bit reserved_58[144];  /* 58, internal Reserved */
	Ifx_STM_OCS OCS;								 /* E8, OCDS Control and Status Register */
	Ifx_STM_KRSTCLR KRSTCLR;				 /* EC, Kernel Reset Status Clear Register */
	Ifx_STM_KRST1 KRST1;						 /* F0, Kernel Reset Register 1 */
	Ifx_STM_KRST0 KRST0;						 /* F4, Kernel Reset Register 0 */
	Ifx_STM_ACCEN1 ACCEN1;					 /* F8, Access Enable Register 1 */
	Ifx_STM_ACCEN0 ACCEN0;					 /* FC, Access Enable Register 0 */
} Ifx_STM;


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/
#endif /* IFXSTM_REGDEF_H */

