

/**
 * \file IfxScu_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 * Version: TC38XA_UM_V1.5.0.R0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *                                 IMPORTANT NOTICE
 * Use of this file is subject to the terms of use agreed between (i) you or 
 * the company in which ordinary course of business you are acting and (ii) 
 * Infineon Technologies AG or its licensees. If and as long as no such 
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or 
 * organization obtaining a copy of the software and accompanying 
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the 
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * \defgroup IfxSfr_Scu_Registers Scu Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Scu_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Scu_Registers
 * 
 * \defgroup IfxSfr_Scu_Registers_union Register unions
 * \ingroup IfxSfr_Scu_Registers
 * 
 * \defgroup IfxSfr_Scu_Registers_struct Memory map
 * \ingroup IfxSfr_Scu_Registers */
#ifndef IFXSCU_REGDEF_H
#define IFXSCU_REGDEF_H 1
/******************************************************************************/
#include "Ifx_TypesReg.h"
/******************************************************************************/

/******************************************************************************/
/* 从一个非零配置切换到另一个非零配置时, 必须先切到00b停钟, 再切到目标值(防glitch) */
/******************************************************************************/

/* ACCEN00:Access Enable Register 00 —— SCU寄存器的"主机访问白名单(下半区)" */
typedef struct _Ifx_SCU_ACCEN00_Bits
{
    Ifx_UReg_32Bit EN0:1;             /* [0] Access Enable for Master TAG ID 0 - EN0(rw)
                                       * Master TAG ID 0是否允许访问这个SCU寄存器块:
                                       *   =1: 允许; =0: 禁止(该Master访问会被阻断/出错);
                                       * Master TAG ID 0~31代表不同的"总线主机":
                                       *   - 各个CPU核(CPU0..3);
                                       *   - DMA控制器;
                                       *   - HSM/Cerberus;
                                       *   - 其它总线master;
                                       * 精确映射需看SCU/Bus Matrix章节里的Master Tag表; */
    Ifx_UReg_32Bit EN1:1;             /* [1] Master TAG ID 1访问许可 */
    Ifx_UReg_32Bit EN2:1;             /* [2] Master TAG ID 2访问许可 */
    Ifx_UReg_32Bit EN3:1;             /* [3] ... */
    Ifx_UReg_32Bit EN4:1;             /* [4] ... */
    Ifx_UReg_32Bit EN5:1;             /* [5] ... */
    Ifx_UReg_32Bit EN6:1;             /* [6] ... */
    Ifx_UReg_32Bit EN7:1;             /* [7] ... */
    Ifx_UReg_32Bit EN8:1;             /* [8] ... */
    Ifx_UReg_32Bit EN9:1;             /* [9] ... */
    Ifx_UReg_32Bit EN10:1;            /* [10] ... */
    Ifx_UReg_32Bit EN11:1;            /* [11] ... */
    Ifx_UReg_32Bit EN12:1;            /* [12] ... */
    Ifx_UReg_32Bit EN13:1;            /* [13] ... */
    Ifx_UReg_32Bit EN14:1;            /* [14] ... */
    Ifx_UReg_32Bit EN15:1;            /* [15] ... */
    Ifx_UReg_32Bit EN16:1;            /* [16] ... */
    Ifx_UReg_32Bit EN17:1;            /* [17] ... */
    Ifx_UReg_32Bit EN18:1;            /* [18] ... */
    Ifx_UReg_32Bit EN19:1;            /* [19] ... */
    Ifx_UReg_32Bit EN20:1;            /* [20] ... */
    Ifx_UReg_32Bit EN21:1;            /* [21] ... */
    Ifx_UReg_32Bit EN22:1;            /* [22] ... */
    Ifx_UReg_32Bit EN23:1;            /* [23] ... */
    Ifx_UReg_32Bit EN24:1;            /* [24] ... */
    Ifx_UReg_32Bit EN25:1;            /* [25] ... */
    Ifx_UReg_32Bit EN26:1;            /* [26] ... */
    Ifx_UReg_32Bit EN27:1;            /* [27] ... */
    Ifx_UReg_32Bit EN28:1;            /* [28] ... */
    Ifx_UReg_32Bit EN29:1;            /* [29] ... */
    Ifx_UReg_32Bit EN30:1;            /* [30] ... */
    Ifx_UReg_32Bit EN31:1;            /* [31] ... */
} Ifx_SCU_ACCEN00_Bits;

/* ACCEN01: 上半字访问控制(当前保留) */
typedef struct _Ifx_SCU_ACCEN01_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /* [31:0] internal Reserved */
} Ifx_SCU_ACCEN01_Bits;

/* ACCEN10:Access Enable Register 10 —— 高优先级/安全视角下的访问掩码 */
typedef struct _Ifx_SCU_ACCEN10_Bits
{
    Ifx_UReg_32Bit EN0:1;             /* [0] Access Enable for Master TAG ID 0 - EN0(rw)
                                       * 这一组ACCEN10/ACCEN11往往是"第二级访问控制",
                                       * 用于安全视角(Safety View)或另一侧的访问权限配置;
                                       * 典型架构是:
                                       *   - ACCEN00/01: 功能视角访问许可;
                                       *   - ACCEN10/11:Safety视角访问许可;
                                       *   - 某个Master要访问寄存器必须同时通过两个视角的许可; */
    Ifx_UReg_32Bit EN1:1;             /* [1] ... (TAG1) */
    Ifx_UReg_32Bit EN2:1;             /* [2] ... */
    Ifx_UReg_32Bit EN3:1;             /* [3] ... */
    Ifx_UReg_32Bit EN4:1;             /* [4] ... */
    Ifx_UReg_32Bit EN5:1;             /* [5] ... */
    Ifx_UReg_32Bit EN6:1;             /* [6] ... */
    Ifx_UReg_32Bit EN7:1;             /* [7] ... */
    Ifx_UReg_32Bit EN8:1;             /* [8] ... */
    Ifx_UReg_32Bit EN9:1;             /* [9] ... */
    Ifx_UReg_32Bit EN10:1;            /* [10] ... */
    Ifx_UReg_32Bit EN11:1;            /* [11] ... */
    Ifx_UReg_32Bit EN12:1;            /* [12] ... */
    Ifx_UReg_32Bit EN13:1;            /* [13] ... */
    Ifx_UReg_32Bit EN14:1;            /* [14] ... */
    Ifx_UReg_32Bit EN15:1;            /* [15] ... */
    Ifx_UReg_32Bit EN16:1;            /* [16] ... */
    Ifx_UReg_32Bit EN17:1;            /* [17] ... */
    Ifx_UReg_32Bit EN18:1;            /* [18] ... */
    Ifx_UReg_32Bit EN19:1;            /* [19] ... */
    Ifx_UReg_32Bit EN20:1;            /* [20] ... */
    Ifx_UReg_32Bit EN21:1;            /* [21] ... */
    Ifx_UReg_32Bit EN22:1;            /* [22] ... */
    Ifx_UReg_32Bit EN23:1;            /* [23] ... */
    Ifx_UReg_32Bit EN24:1;            /* [24] ... */
    Ifx_UReg_32Bit EN25:1;            /* [25] ... */
    Ifx_UReg_32Bit EN26:1;            /* [26] ... */
    Ifx_UReg_32Bit EN27:1;            /* [27] ... */
    Ifx_UReg_32Bit EN28:1;            /* [28] ... */
    Ifx_UReg_32Bit EN29:1;            /* [29] ... */
    Ifx_UReg_32Bit EN30:1;            /* [30] ... */
    Ifx_UReg_32Bit EN31:1;            /* [31] ... */
} Ifx_SCU_ACCEN10_Bits;

/* ACCEN11: 上半字访问控制(当前保留) */
typedef struct _Ifx_SCU_ACCEN11_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /* [31:0] internal Reserved */
} Ifx_SCU_ACCEN11_Bits;

/* ARSTDIS:Application Reset Disable —— 禁用"某些源触发的应用复位" */
typedef struct _Ifx_SCU_ARSTDIS_Bits
{
    Ifx_UReg_32Bit STM0DIS:1;         /* [0] STM0 Disable Reset - STM0DIS(rw)
                                       * =1: 禁止"STM0 Compare Match"触发应用级复位;
                                       *  即使RSTCON.STM0配置了Application Reset,
                                       *  设置STM0DIS=1也能屏蔽这个reset动作;
                                       * =0: 允许STM0根据RSTCON配置触发应用复位; */
    Ifx_UReg_32Bit STM1DIS:1;         /* [1] STM1 Disable Reset - STM1DIS(rw)
                                       * 同理, 禁止/允许STM1触发应用复位; */
    Ifx_UReg_32Bit STM2DIS:1;         /* [2] STM2 Disable Reset - STM2DIS(rw) */
    Ifx_UReg_32Bit STM3DIS:1;         /* [3] STM3 Disable Reset - STM3DIS(rw) */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit reserved_5:1;      /* [5] 保留 */
    Ifx_UReg_32Bit reserved_6:2;      /* [7:6] 保留 */
    Ifx_UReg_32Bit reserved_8:24;     /* [31:8] 保留 */
} Ifx_SCU_ARSTDIS_Bits;

/* CCUCON0控制的是: 以一个源时钟(CLKSEL选出来的)为基础, 给下面这些域分频:
 *  STMDIV → 给STM(系统定时器)用
 *  GTMDIV → 给GTM时钟域用
 *  SRIDIV → 给SRI总线(CPU ↔ 大外设)用
 *  LPDIV → 给低功耗域(LP clock)用
 *  SPBDIV → 给SPB总线(外设总线)用
 *  BBBDIV → 给BBB之类的桥接总线用
 *  FSIDIV/FSI2DIV → 给FSI/FSI2内部互连用
 *  CLKSEL: 选择源时钟, 0: SYS PLL(PLL0); 1: Backup Clock(内部振荡器)
 *  UP: 原子更新机制, 写1即是请求把刚写的寄存器值一起生效"
 *  LCK: = 0 意味着可以写新的分频值/发起新的更新 */
typedef struct _Ifx_SCU_CCUCON0_Bits
{
    Ifx_UReg_32Bit STMDIV:4;          /* [3:0] STM Divider Reload Value - STMDIV (rw) */
    Ifx_UReg_32Bit GTMDIV:4;          /* [7:4] GTM Divider Reload Value - GTMDIV (rw) */
    Ifx_UReg_32Bit SRIDIV:4;          /* [11:8] SRI Divider Reload Value - SRIDIV (rw) */
    Ifx_UReg_32Bit LPDIV:3;           /* [14:12] Low Power Divider Reload Value - LPDIV (rw) */
    Ifx_UReg_32Bit reserved_15:1;     /* [15:15] internal Reserved */
    Ifx_UReg_32Bit SPBDIV:4;          /* [19:16] SPB Divider Reload Value - SPBDIV (rw) */
    Ifx_UReg_32Bit BBBDIV:4;          /* [23:20] BBB Divider Reload Value - BBBDIV (rw) */
    Ifx_UReg_32Bit FSIDIV:2;          /* [25:24] FSI Divider Reload Value - FSIDIV (rw) */
    Ifx_UReg_32Bit FSI2DIV:2;         /* [27:26] FSI2 Divider Reload Value - FSI2DIV (rw) */
    Ifx_UReg_32Bit CLKSEL:2;          /* [29:28] Clock Selection for Source - CLKSEL (rwh) */
    Ifx_UReg_32Bit UP:1;              /* [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /* [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON0_Bits;

/* CCU Clock Control Register 1 */
typedef struct _Ifx_SCU_CCUCON1_Bits
{
    Ifx_UReg_32Bit MCANDIV:4;         /* [3:0] 给MCAN模块的内部时钟fMCANI分频 (rw) */
    Ifx_UReg_32Bit CLKSELMCAN:2;      /* [5:4] 选MCAN的时钟从哪来 (rw) */
    Ifx_UReg_32Bit reserved_6:1;      /* [6:6] internal Reserved */
    Ifx_UReg_32Bit PLL1DIVDIS:1;      /* [7:7] 决定fsource1是PLL1半频还是全频(前提是CCUCON0. CLKSEL = 01) (rw) */
    Ifx_UReg_32Bit I2CDIV:4;          /* [11:8] 生成I2C模块时钟fI2C的分频数 (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /* [15:12] internal Reserved */
    Ifx_UReg_32Bit MSCDIV:4;          /* [19:16] MSC模块的时钟 = 选一个源(CLKSELMSC) → 再用MSCDIV分频 (rw) */
    Ifx_UReg_32Bit CLKSELMSC:2;       /* [21:20] MSC时钟源选择 (rw) */
    Ifx_UReg_32Bit reserved_22:2;     /* [23:22] internal Reserved */
    Ifx_UReg_32Bit QSPIDIV:4;         /* [27:24] QSPI模块时钟 = 选一个源(CLKSELQSPI) → 再用QSPIDIV分频 (rw) */
    Ifx_UReg_32Bit CLKSELQSPI:2;      /* [29:28] QSPI时钟源选择 (rw) */
    Ifx_UReg_32Bit reserved_30:1;     /* [30:30] internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /* [31:31] = 0: 寄存器解锁, 可以写新配置 (rh) */
} Ifx_SCU_CCUCON1_Bits;

/* CCU Clock Control Register 2 */
typedef struct _Ifx_SCU_CCUCON2_Bits
{
    Ifx_UReg_32Bit ASCLINFDIV:4;      /* [3:0] 给ASCLIN的"快速时钟路径"做分频 (rw) */
    Ifx_UReg_32Bit reserved_4:4;      /* [7:4] internal Reserved */
    Ifx_UReg_32Bit ASCLINSDIV:4;      /* [11:8] 给ASCLIN的"慢速时钟路径"做分频 (rw) */
    Ifx_UReg_32Bit CLKSELASCLINS:2;   /* [13:12] 给ASCLIN的Slow分支选时钟从哪来 (rw) */
    Ifx_UReg_32Bit reserved_14:10;    /* [23:14] internal Reserved */
    Ifx_UReg_32Bit reserved_24:1;     /* [24:24] internal Reserved */
    Ifx_UReg_32Bit ERAYPERON:1;       /* [25:25] 控制ERAY(FlexRay)模块的时钟是否允许被"安全关断" (rw) */
    Ifx_UReg_32Bit reserved_26:1;     /* [26:26] internal Reserved */
    Ifx_UReg_32Bit reserved_27:4;     /* [30:27] internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /* [31:31] 显示CCUCON2目前是不是"正在更新"/"可写" (rh) */
} Ifx_SCU_CCUCON2_Bits;

/* CCU Clock Control Register 3 */
/* PLL0MONEN/PLL1MONEN/PLL2MONEN/SPBMONEN/BACKMONEN: "心跳监控"使能设置
 * 一旦异常, 就通过SMU/故障标志告诉你, 甚至触发复位(具体行为由SMU配置决定)
 * 开发/FuSa: 通常会按安全要求打开关键那几路, 并在SMU配好报警和反应 */
typedef struct _Ifx_SCU_CCUCON3_Bits
{
    Ifx_UReg_32Bit PLL0MONEN:1;       /* [0:0] PLL0 Clock Monitor Enable - PLL0MONEN (rw) */
    Ifx_UReg_32Bit PLL1MONEN:1;       /* [1:1] PLL1 Clock Monitor Enable - PLL1MONEN (rw) */
    Ifx_UReg_32Bit PLL2MONEN:1;       /* [2:2] PLL2 Clock Monitor Enable - PLL2MONEN (rw) */
    Ifx_UReg_32Bit SPBMONEN:1;        /* [3:3] SPB Clock Monitor Enable - SPBMONEN (rw) */
    Ifx_UReg_32Bit BACKMONEN:1;       /* [4:4] Backup Clock Monitor Enable - BACKMONEN (rw) */
    Ifx_UReg_32Bit reserved_5:3;      /* [7:5] internal Reserved */
    Ifx_UReg_32Bit PLL0MONTST:1;      /* [8:8] 模拟"时钟坏了"的自测开关, 骗监控器: 这路钟已经坏了, 看你报警不报警 (rw) */
    Ifx_UReg_32Bit PLL1MONTST:1;      /* [9:9] PLL1 Clock Monitor Test - PLL1MONTST (rw) */
    Ifx_UReg_32Bit PLL2MONTST:1;      /* [10:10] PLL2 Clock Monitor Test - PLL2MONTST (rw) */
    Ifx_UReg_32Bit SPBMONTST:1;       /* [11:11] SPB Clock Monitor Test - SPBMONTST (rw) */
    Ifx_UReg_32Bit BACKMONTST:1;      /* [12:12] Backup Clock Monitor Test - BACKMONTST (rw) */
    Ifx_UReg_32Bit reserved_13:11;    /* [23:13] internal Reserved */
    Ifx_UReg_32Bit reserved_24:6;     /* [29:24] internal Reserved */
    Ifx_UReg_32Bit UP:1;              /* [30:30] UP/LCK —— 更新确认机制 (w) */
    Ifx_UReg_32Bit LCK:1;             /* [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON3_Bits;

/* CCU Clock Control Register 4
 * 专门给"备份时钟(Backup Clock)"做体检用的
 *  LOTHR[11: 0] —— 备份时钟"太慢"的阈值
 *  UPTHR[23: 12] —— 备份时钟"太快"的阈值
 *  MONEN[24] —— 开关"备份时钟监控"
 *  MONTST[25] —— 模拟"备份时钟出故障"的自测开关
 *  UP[30]/LCK[31] —— 一次性生效 + 更新状态 */
typedef struct _Ifx_SCU_CCUCON4_Bits
{
    Ifx_UReg_32Bit LOTHR:12;          /* [11:0] Backup Clock Monitor Lower Threshold - LOTHR (rw) */
    Ifx_UReg_32Bit UPTHR:12;          /* [23:12] Backup Clock Monitor Upper Threshold - UPTHR (rw) */
    Ifx_UReg_32Bit MONEN:1;           /* [24:24] Backup Clock Monitor Enable - MONEN (rw) */
    Ifx_UReg_32Bit MONTST:1;          /* [25:25] Backup Clock Monitor Test - MONTST (rw) */
    Ifx_UReg_32Bit reserved_26:4;     /* [29:26] internal Reserved */
    Ifx_UReg_32Bit UP:1;              /* [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /* [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON4_Bits;

/* CCU Clock Control Register 5
 * 给千兆以太网和高速CAN各分一根合适的时钟"的控制板 */
typedef struct _Ifx_SCU_CCUCON5_Bits
{
    Ifx_UReg_32Bit GETHDIV:4;         /* [3:0] 从上游来的"外设高速时钟"里, 分一条给GETH模块, 用GETHDIV决定"除以几" (rw) */
    Ifx_UReg_32Bit MCANHDIV:4;        /* [7:4] 给MCAN高速域(MCANH)分一条时钟, 用MCANHDIV决定"除以几" (rw) */
    Ifx_UReg_32Bit reserved_8:4;      /* [11:8] internal Reserved */
    Ifx_UReg_32Bit reserved_12:18;    /* [29:12] internal Reserved */
    Ifx_UReg_32Bit UP:1;              /* [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /* [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON5_Bits;

/* 给每个CPU核单独配一个"主频分频器" */
/* CCU Clock Control Register 6 */
typedef struct _Ifx_SCU_CCUCON6_Bits
{
    Ifx_UReg_32Bit CPU0DIV:6;         /* [5:0] CPU0 Divider Reload Value - CPU0DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /* [31:6] internal Reserved */
} Ifx_SCU_CCUCON6_Bits;
/* CCU Clock Control Register 7 */
typedef struct _Ifx_SCU_CCUCON7_Bits
{
    Ifx_UReg_32Bit CPU1DIV:6;         /* [5:0] CPU1 Divider Reload Value - CPU1DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /* [31:6] internal Reserved */
} Ifx_SCU_CCUCON7_Bits;
/* CCU Clock Control Register 8 */
typedef struct _Ifx_SCU_CCUCON8_Bits
{
    Ifx_UReg_32Bit CPU2DIV:6;         /* [5:0] CPU2 Divider Reload Value - CPU2DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /* [31:6] internal Reserved */
} Ifx_SCU_CCUCON8_Bits;
/* CCU Clock Control Register 9 */
typedef struct _Ifx_SCU_CCUCON9_Bits
{
    Ifx_UReg_32Bit CPU3DIV:6;         /* [5:0] CPU3 Divider Reload Value - CPU3DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /* [31:6] internal Reserved */
} Ifx_SCU_CCUCON9_Bits;

/* CHIPID: 芯片身份证(版本/封装/容量/变种/安全能力) */
typedef struct _Ifx_SCU_CHIPID_Bits
{
    Ifx_UReg_32Bit CHREV:6;           /* [5:0] Chip Revision Number - CHREV(r)
                                       * 芯片修订号:A-step/B-step/C-step … 用数字编码;
                                       * - 不同硅步进(含bug修复/工艺变化)会有不同的CHREV;
                                       * - 启动日志里可以打印出来, 方便区分客户板上到底是哪个步进; */
    Ifx_UReg_32Bit CHTEC:2;           /* [7:6] Chip Family - CHTEC(r)
                                       * 芯片家族/技术类型, 比如TC3xx家族中的具体子系列;
                                       * 应用层通常只用于识别, 不参与控制逻辑; */
    Ifx_UReg_32Bit CHPK:4;            /* [11:8] Chip Package - CHPK(rw)
                                       * 封装类型信息: 如BGA-292/BGA-516等;
                                       * 一般为只读或只写一次的硬件配置信息, 定义了引脚数量/布局; */
    Ifx_UReg_32Bit CHID:4;            /* [15:12] Chip Product - CHID(rw)
                                       * 产品系列ID: 区分不同"产品线"(同一家族下的不同型号); */
    Ifx_UReg_32Bit EEA:1;             /* [16] Emulation or ADAS Extension Available - EEA(rh)
                                       * 标记是否有Emulation/ADAS扩展(例如额外的Trace/仿真逻辑或ADAS功能块); */
    Ifx_UReg_32Bit UCODE:7;           /* [23:17] μCode Version - UCODE(rw)
                                       * 内部 μCode版本号(例如内建BootROM/FW的版本);
                                       * 有助于跟踪ROM固件版本差异; */
    Ifx_UReg_32Bit FSIZE:4;           /* [27:24] Program Flash Size - FSIZE(rw)
                                       * PFlash容量信息(编码表示1MB/2MB/4MB等),
                                       * 用于软件在运行时确认"我到底有多大Flash可用"; */
    Ifx_UReg_32Bit VART:3;            /* [30:28] Variant - VART(rw)
                                       * 变种/衍生型号, 例如带/不带HSM, 带/不带2nd Ethernet等; */
    Ifx_UReg_32Bit SEC:1;             /* [31] Security Device Available - SEC(rw)
                                       * 标记是否为带安全特性的器件(有无HSM/安全启动等); */
} Ifx_SCU_CHIPID_Bits;

/* DTSCLIM: 芯片内部温度传感器的上下限和中断配置 */
typedef struct _Ifx_SCU_DTSCLIM_Bits
{
    Ifx_UReg_32Bit LOWER:12;          /* [11:0] DTSC Lower Limit - LOWER(rw)
                                       * 温度下限阈值(ADC编码), 低于此值触发"低温异常"/下限事件;
                                       * 需要结合芯片手册给的温度-ADC线性关系计算; */
    Ifx_UReg_32Bit reserved_12:1;     /* [12] 保留 */
    Ifx_UReg_32Bit BGPOK:1;           /* [13] DTSC Bandgap OK(rh)
                                       * Bandgap参考是否正常稳定:
                                       *   =1: 参考电路OK, 温度测量有效;
                                       *   =0: 参考未稳定, 不可信; */
    Ifx_UReg_32Bit EN:1;              /* [14] DTSC Enable(rw)
                                       * Temperature Sensor Enable:
                                       *   =1: 启用芯片内部温度传感器;
                                       *   =0: 禁用(可用于节能或测试时关闭); */
    Ifx_UReg_32Bit LLU:1;             /* [15] DTSC Lower Limit Underflow - LLU(rwh)
                                       * =1: 温度测量值曾经低于LOWER阈值(下限越界);
                                       * 写1: 清该标志; */
    Ifx_UReg_32Bit UPPER:12;          /* [27:16] DTSC Upper Limit - UPPER(rw)
                                       * 温度上限阈值(ADC编码), 高于此值触发"过温"事件; */
    Ifx_UReg_32Bit INTEN:1;           /* [28] DTSC Interrupt Enable(rw)
                                       * =1: 当温度越界(高于UPPER或低于LOWER)时, 生成中断;
                                       * =0: 只置LLU/UOF/INT标志, 不产中断; */
    Ifx_UReg_32Bit reserved_29:1;     /* [29] 保留 */
    Ifx_UReg_32Bit INT:1;             /* [30] DTSC Interrupt status flag(rwh)
                                       * =1: 已触发温度中断; 写1清除该状态; */
    Ifx_UReg_32Bit UOF:1;             /* [31] DTSC Upper Limit Overflow - UOF(rwh)
                                       * =1: 温度曾经高于UPPER阈值(上限越界), 写1清除; */
} Ifx_SCU_DTSCLIM_Bits;

/* DTSCSTAT: 重心就是读当前温度测量结果(ADC码) */
typedef struct _Ifx_SCU_DTSCSTAT_Bits
{
    Ifx_UReg_32Bit RESULT:12;         /* [11:0] Result of the DTSC Measurement - RESULT(rh)
                                       * 当前温度测量值(ADC编码), 需要用线性公式换算到摄氏度:
                                       *   T(°C) ≈ a * RESULT + b(具体a/b看datasheet的DTS标定段); */
    Ifx_UReg_32Bit reserved_12:20;    /* [31:12] 保留 */
} Ifx_SCU_DTSCSTAT_Bits;

/* EICON0: 全局(非Safety)ENDINIT控制寄存器0 —— 结构与SEICON0类似 */
typedef struct _Ifx_SCU_EICON0_Bits
{
    Ifx_Strict_32Bit reserved_0:1;    /* [0] 保留 */
    Ifx_Strict_32Bit ENDINIT:1;       /* [1] End-of-Initialization Control Bit - ENDINIT(rwh)
                                       * 普通(非Safety)ENDINIT锁:
                                       *   - 用于保护一部分关键寄存器(但安全等级不如Safety ENDINIT);
                                       *   - 操作流程和Safety版本类似(通过密码+序列短暂解锁, 改完再上锁); */
    Ifx_Strict_32Bit EPW:14;          /* [15:2] User-Definable ENDINIT Password Field - EPW(rwh)
                                       * 非Safety ENDINIT的密码字段, 控制谁能修改ENDINIT; */
    Ifx_Strict_32Bit REL:16;          /* [31:16] Reload Value for the ENDINIT Timeout Counter - REL(r)
                                       * 对应ENDINIT超时计数器的重装值, 定义解锁窗口最长时间; */
} Ifx_SCU_EICON0_Bits;

/* EICON1: 全局ENDINIT的时钟/禁用控制(类似SEICON1) */
typedef struct _Ifx_SCU_EICON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0] 保留 */
    Ifx_UReg_32Bit reserved_1:1;      /* [1] 保留 */
    Ifx_UReg_32Bit IR0:1;             /* [2] Input Frequency Request Control - IR1, IR0(rw)
                                       * 与IR1一起选择ENDINIT timeout计数器的输入频率:
                                       *   不同组合 = 不同计时频率 = 不同解锁窗口时间; */
    Ifx_UReg_32Bit DR:1;              /* [3] Disable Request Control Bit - DR(rw)
                                       * 请求禁用(普通)ENDINIT机制:
                                       *   =1: 完全关闭ENDINIT保护(危险操作),
                                       *   =0: 正常启用ENDINIT保护;
                                       * 一般只在特定测试/调试模式下使用, 量产不建议打开; */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit IR1:1;             /* [5] Input Frequency Request Control - IR1(rw)
                                       * 与IR0一起选频率配置; */
    Ifx_UReg_32Bit reserved_6:26;     /* [31:6] 保留 */
} Ifx_SCU_EICON1_Bits;

/* EICR:External Input Channel Register —— ERU/外部事件通道配置 */
typedef struct _Ifx_SCU_EICR_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /* [3:0] 保留 */
    Ifx_UReg_32Bit EXIS0:3;           /* [6:4] External Input Selection 0 - EXIS0(rw)
                                       * 选择"外部输入0(信号源0)"连在哪个物理信号上:
                                       *   - EXIS0=000: 比如Port Px.x
                                       *   - EXIS0=001: 比如Port Py.y
                                       *   - ...
                                       *   具体映射看SCU/ERU章节中的EXIS0表;
                                       * 这是ERU通道的"信号来源选择开关"; */
    Ifx_UReg_32Bit reserved_7:1;      /* [7] 保留 */
    Ifx_UReg_32Bit FEN0:1;            /* [8] Falling Edge Enable 0 - FEN0(rw)
                                       * =1: 使能对External Input 0的"下降沿"检测;
                                       * =0: 不对下降沿敏感; */
    Ifx_UReg_32Bit REN0:1;            /* [9] Rising Edge Enable 0 - REN0(rw)
                                       * =1: 使能对"上升沿"检测;
                                       * 与FEN0组合可以实现:
                                       *   - 只上升边触发;
                                       *   - 只下降边触发;
                                       *   - 双边沿触发(FEN0=1 & REN0=1); */
    Ifx_UReg_32Bit LDEN0:1;           /* [10] Level Detection Enable 0 - LDEN0(rw)
                                       * =1: 启用电平检测(高/低), 而不仅是边沿;
                                       * 适合实现"高电平持续一段时间触发"的情况; */
    Ifx_UReg_32Bit EIEN0:1;           /* [11] External Input Enable 0 - EIEN0(rw)
                                       * =1: 启用External Input 0;
                                       * =0: 完全关闭这路输入(边沿/电平都不观察); */
    Ifx_UReg_32Bit INP0:3;            /* [14:12] Input Node Pointer - INP0(rw)
                                       * 选择"通道0的检测结果"要送到哪个"输入节点"(通常是连接到某个服务请求/中断线):
                                       *   - INP0决定这路事件最终会路由到哪一组输出(比如OGU/执行单元); */
    Ifx_UReg_32Bit reserved_15:5;     /* [19:15] 保留 */
    Ifx_UReg_32Bit EXIS1:3;           /* [22:20] External Input Selection 1 - EXIS1(rw)
                                       * 通道1的外部输入源选择, 与EXIS0一样, 只是对应第二路输入; */
    Ifx_UReg_32Bit reserved_23:1;     /* [23] 保留 */
    Ifx_UReg_32Bit FEN1:1;            /* [24] Falling Edge Enable 1 - FEN1(rw) */
    Ifx_UReg_32Bit REN1:1;            /* [25] Rising Edge Enable 1 - REN1(rw) */
    Ifx_UReg_32Bit LDEN1:1;           /* [26] Level Detection Enable 1 - LDEN1(rw) */
    Ifx_UReg_32Bit EIEN1:1;           /* [27] External Input Enable 1 - EIEN1(rw) */
    Ifx_UReg_32Bit INP1:3;            /* [30:28] Input Node Pointer - INP1(rw)
                                       * 通道1检测结果送到哪个"目标节点/中断线"; */
    Ifx_UReg_32Bit reserved_31:1;     /* [31] 保留 */
} Ifx_SCU_EICR_Bits;

/* EIFILT:External Input Filter Register —— 给指定REQxX通道加数字消抖滤波 */
typedef struct _Ifx_SCU_EIFILT_Bits
{
    Ifx_UReg_32Bit FILRQ0A:1;         /* [0] Filter Enable for REQ0A - FILRQ0A(rw)
                                       * =1: 对REQ0A这路外部请求信号启用数字滤波(防毛刺/抖动);
                                       * 其余字段FILRQyX同理, 只是对应不同REQ通道; */
    Ifx_UReg_32Bit FILRQ5A:1;         /* [1] Filter Enable for REQ5A - FILRQ5A(rw) */
    Ifx_UReg_32Bit FILRQ2A:1;         /* [2] ... */
    Ifx_UReg_32Bit FILRQ3A:1;         /* [3] ... */
    Ifx_UReg_32Bit FILRQ0C:1;         /* [4] ... */
    Ifx_UReg_32Bit FILRQ1C:1;         /* [5] ... */
    Ifx_UReg_32Bit FILRQ3C:1;         /* [6] ... */
    Ifx_UReg_32Bit FILRQ2C:1;         /* [7] ... */
    Ifx_UReg_32Bit FILRQ4A:1;         /* [8] ... */
    Ifx_UReg_32Bit FILRQ6A:1;         /* [9] ... */
    Ifx_UReg_32Bit FILRQ1A:1;         /* [10] ... */
    Ifx_UReg_32Bit FILRQ7A:1;         /* [11] ... */
    Ifx_UReg_32Bit FILRQ6D:1;         /* [12] ... */
    Ifx_UReg_32Bit FILRQ4D:1;         /* [13] ... */
    Ifx_UReg_32Bit FILRQ2B:1;         /* [14] ... */
    Ifx_UReg_32Bit FILRQ3B:1;         /* [15] ... */
    Ifx_UReg_32Bit FILRQ7C:1;         /* [16] ... */
    Ifx_UReg_32Bit reserved_17:7;     /* [23:17] 保留 */
    Ifx_UReg_32Bit FILTDIV:4;         /* [27:24] Digital Glitch Filter Clock Predivider - FILTDIV(rw)
                                       * 数字滤波器采样时钟的预分频:
                                       *   - 决定滤波器采样速度;
                                       *   - 例如用主时钟/某总线时钟分频后作为滤波clock;
                                       * FILTDIV越大 → 采样越慢 → 更强的滤波(但响应慢); */
    Ifx_UReg_32Bit DEPTH:4;           /* [31:28] Digital Glitch Filter Depth - DEPTH(rw)
                                       * 滤波深度(N个连续采样一致才认为有效):
                                       *   - 越大 → 抗毛刺能力越强, 但响应延迟越大;
                                       *   - 越小 → 稍有毛刺也会当作信号边沿; */
} Ifx_SCU_EIFILT_Bits;

/* EIFR: 外部事件标志寄存器 —— 哪个EICR通道发生了事件 */
typedef struct _Ifx_SCU_EIFR_Bits
{
    Ifx_UReg_32Bit INTF0:1;           /* [0] External Event Flag of Channel 0 - INTF0(rh)
                                       * =1: 通道0检测到符合配置的事件(边沿/电平), 产生了一个"外部事件"; */
    Ifx_UReg_32Bit INTF1:1;           /* [1] 通道1事件标志 */
    Ifx_UReg_32Bit INTF2:1;           /* [2] 通道2事件标志 */
    Ifx_UReg_32Bit INTF3:1;           /* [3] 通道3事件标志 */
    Ifx_UReg_32Bit INTF4:1;           /* [4] 通道4事件标志 */
    Ifx_UReg_32Bit INTF5:1;           /* [5] 通道5事件标志 */
    Ifx_UReg_32Bit INTF6:1;           /* [6] 通道6事件标志 */
    Ifx_UReg_32Bit INTF7:1;           /* [7] 通道7事件标志 */
    Ifx_UReg_32Bit reserved_8:24;     /* [31:8] 保留 */
} Ifx_SCU_EIFR_Bits;

/* EISR:ENDINIT Timeout Counter Status(普通ENDINIT的版本, 结构类似SEISR) */
typedef struct _Ifx_SCU_EISR_Bits
{
    Ifx_UReg_32Bit AE:1;              /* [0] EICON0 Access Error Status Flag - AE(rh)
                                       * EICON0/1访问错误(密码/顺序不对); */
    Ifx_UReg_32Bit OE:1;              /* [1] EI Timeout Overflow Error Status Flag - OE(rh)
                                       * 普通ENDINIT解锁窗口超时溢出; */
    Ifx_UReg_32Bit IS0:1;             /* [2] EI Timeout Input Clock Status - IS0(rh) */
    Ifx_UReg_32Bit DS:1;              /* [3] EI Timeout Enable/Disable Status Flag - DS(rh) */
    Ifx_UReg_32Bit TO:1;              /* [4] EI Time-Out Mode Flag - TO(rh) */
    Ifx_UReg_32Bit IS1:1;             /* [5] EI Timeout Input Clock Status - IS1(rh) */
    Ifx_UReg_32Bit reserved_6:10;     /* [15:6] 保留 */
    Ifx_UReg_32Bit TIM:16;            /* [31:16] Timer Value - TIM(rh)
                                       * 普通ENDINIT超时计数器当前数值; */
} Ifx_SCU_EISR_Bits;

/* EMSR:Emergency Stop Register —— Emergency Stop输入配置 & 状态 */
typedef struct _Ifx_SCU_EMSR_Bits
{
    Ifx_UReg_32Bit POL:1;             /* [0] Input Polarity - POL(rw)
                                       * Emergency Stop输入极性:
                                       *   =0: 例如低电平表示"正常", 高电平表示"紧急停";
                                       *   =1: 反相(高为正常/低为紧急停);
                                       * 具体高低有效, 以芯片安全手册为准; */
    Ifx_UReg_32Bit MODE:1;            /* [1] Mode Selection - MODE(rw)
                                       * Emergency Stop的工作模式:
                                       *   - 某些芯片支持"锁存模式/电平模式":
                                       *       MODE=0: 电平模式(信号恢复时可释放);
                                       *       MODE=1: 锁存模式(触发后需软件/SMU介入解除); */
    Ifx_UReg_32Bit ENON:1;            /* [2] Enable ON - ENON(rw)
                                       * 是否启用Emergency Stop功能:
                                       *   =1: 使能, 外部Emergency Stop信号和SMU Emergency Stop会起作用;
                                       *   =0: 禁用Emergency Stop逻辑; */
    Ifx_UReg_32Bit PSEL:1;            /* [3] PORT Select - PSEL(rw)
                                       * 选择哪个管脚作为Emergency Stop输入:
                                       *   - 如某个端口线/专用引脚, 具体映射看EMSR章节;
                                       *   - 便于在不同封装/板级设计下, 选用合适的引脚; */
    Ifx_UReg_32Bit reserved_4:12;     /* [15:4] 保留 */
    Ifx_UReg_32Bit EMSF:1;            /* [16] Emergency Stop Flag - EMSF(rh)
                                       * =1: 检测到了实际的Emergency Stop触发(硬件路径触发); */
    Ifx_UReg_32Bit SEMSF:1;           /* [17] SMU Emergency Stop Flag - SEMSF(rh)
                                       * =1: 由SMU触发的Emergency Stop, 表明发生了严重的安全故障; */
    Ifx_UReg_32Bit reserved_18:14;    /* [31:18] 保留 */
} Ifx_SCU_EMSR_Bits;

/* EMSSW: 软件设置/清除Emergency Stop标志 */
typedef struct _Ifx_SCU_EMSSW_Bits
{
    Ifx_UReg_32Bit reserved_0:24;     /* [23:0] 保留 */
    Ifx_UReg_32Bit EMSFM:2;           /* [25:24] Emergency Stop Flag Modification - EMSFM(w)
                                       * 软件修改EMSF标志位的控制字段:
                                       *   常见模式(示例, 具体看手册):
                                       *     00: 不动作
                                       *     01: 设置EMSF=1(模拟硬件E-Stop)
                                       *     10: 清除EMSF
                                       * 用于:
                                       *   - 测试Emergency Stop处理;
                                       *   - 处理完后清除标志; */
    Ifx_UReg_32Bit SEMSFM:2;          /* [27:26] SMU Emergency Stop Flag Modification - SEMSFM(w)
                                       * 同理, 用于修改SEMSF(SMU E-Stop标志):
                                       *   - 01: 设置SEMSF;
                                       *   - 10: 清除SEMSF; */
    Ifx_UReg_32Bit reserved_28:4;     /* [31:28] 保留 */
} Ifx_SCU_EMSSW_Bits;

/* ESRCFGX:ESR输入的边沿检测配置 */
typedef struct _Ifx_SCU_ESRCFGX_ESRCFGX_Bits
{
    Ifx_UReg_32Bit reserved_0:7;      /* [6:0] 保留 */
    Ifx_UReg_32Bit EDCON:2;           /* [8:7] Edge Detection Control - EDCON(rw)
                                       * 配置ESRx输入的边沿检测模式:
                                       *   - 00: 不检测边沿(只用于复位/电平判断);
                                       *   - 01: 检测上升沿;
                                       *   - 10: 检测下降沿;
                                       *   - 11: 检测双边沿;
                                       * 对应的是对ESR引脚的"作为普通事件输入"时的配置(和pure reset不完全一样); */
    Ifx_UReg_32Bit reserved_9:23;     /* [31:9] 保留 */
} Ifx_SCU_ESRCFGX_ESRCFGX_Bits;

/* ESROCFG:ESR输出配置寄存器(主要是App Reset指示) */
typedef struct _Ifx_SCU_ESROCFG_Bits
{
    Ifx_UReg_32Bit ARI:1;             /* [0] Application Reset Indicator - ARI(rh)
                                       * =1: 最近经历了一次Application Reset(应用层复位), 由某些源触发;
                                       * 例如软件复位/SMU应答等;
                                       * 通常在启动代码中读取, 用于区分:
                                       *   - 是POR/System Reset还是App Reset; */
    Ifx_UReg_32Bit ARC:1;             /* [1] Application Reset Indicator Clear - ARC(w)
                                       * 写1: 清除ARI标志;
                                       * 通常在软件记录完"这是一次App Reset"后调用ARC清掉, 准备下一次记录; */
    Ifx_UReg_32Bit reserved_2:30;     /* [31:2] 保留 */
} Ifx_SCU_ESROCFG_Bits;

/* External Clock Control Register */
/* 外部时钟控制寄存器:把芯片里的某路时钟"搬到外部引脚"给别人用或拿示波器量 */
typedef struct _Ifx_SCU_EXTCON_Bits
{
    Ifx_UReg_32Bit EN0:1;             /* [0] EXTCLK0使能开关
                                       *      =0: EXTCLK0引脚不输出时钟(关闭/三态)
                                       *      =1: 按SEL0选择的那路内部时钟从EXTCLK0引脚输出 */
    Ifx_UReg_32Bit reserved_1:1;      /* [1] 保留, 读出可能为0/未定义, 写时必须写0 */
    Ifx_UReg_32Bit SEL0:4;            /* [5:2] EXTCLK0输出的时钟源选择
                                       *   4bit编码, 具体含义要看手册里的EXTCON.SEL0表:
                                       *   举例(逻辑上大概是这种风格):
                                       *     0000: 不输出/保留
                                       *     0001: 输出某个PLL时钟(比如fPLL0)
                                       *     0010: 输出BACKUP时钟
                                       *     0011: 输出SRI时钟
                                       *     0100: 输出SPB时钟
                                       *     ……(实际哪一位代表谁, 要查SCU章节)
                                       *   作用:选择"芯片内部哪路时钟"送到EXTCLK0这根外部管脚上 */
    Ifx_UReg_32Bit reserved_6:10;     /* [15:6] 保留位, 写0, 别动 */
    Ifx_UReg_32Bit EN1:1;             /* [16] EXTCLK1使能开关
                                       *      =0: EXTCLK1引脚关掉(不输出时钟)
                                       *      =1: EXTCLK1打开, 输出根据SEL1 + DIV1 + NSEL配置后的时钟 */
    Ifx_UReg_32Bit NSEL:1;            /* [17] Negation Selection:波形是否取反
                                       *      =0: 正常极性输出(0->0, 1->1)
                                       *      =1: 把内部时钟翻转后再输出(0->1, 1->0)
                                       *   一般用于做相位/极性兼容, 有特殊需求才会用 */
    Ifx_UReg_32Bit SEL1:4;            /* [21:18] EXTCLK1的时钟源选择
                                       *   跟SEL0类似, 也是4bit, 具体编码看手册:
                                       *   可能的源:PLL0/PLL1/PLL2、SRI/SPB、ETH时钟、GTM时钟、BACKUP等
                                       *   作用:先在内部挑一条源时钟, 作为EXTCLK1的基准, 再由DIV1分频 */
    Ifx_UReg_32Bit reserved_22:2;     /* [23:22] 保留, 写0 */
    Ifx_UReg_32Bit DIV1:8;            /* [31:24] EXTCLK1分频值
                                       *   决定EXTCLK1 = 源时钟/ (DIV1+1)或类似关系(具体公式看手册)
                                       *   典型用途:
                                       *     - 源时钟太快(几百MHz), 直接输出不现实, 先分到一个适合示波器/外设的频率
                                       *     - 比如:源=200MHz, DIV1=9 -> 输出≈ 200/(9+1)=20MHz
                                       *   注意:EXTCLK0没配分频字段, EXTCLK1有DIV1, 可以细调频率 */
} Ifx_SCU_EXTCON_Bits;


/* Fractional Divider Register */
/* 分数分频寄存器:把一条输入时钟"压成"某个目标频率用的小齿轮, 支持小数分频 */
/* 几乎每个需要独立生成时钟的模块都有一个自己的FDR(比如ASCLINn_FDR, I2C_FDR, QSPI_FDR), Ifx_SCU_FDR_Bits是这些寄存器的通用位定义 */
typedef struct _Ifx_SCU_FDR_Bits
{
    Ifx_UReg_32Bit STEP:10;           /* [9:0]  Step Value - STEP(rw)
                                       * 这是"分频步进系数", 决定输出时钟到底多快/多慢;
                                       * 在不同的Divider Mode下, STEP的意义略有差别, 但核心就是:
                                       *   - 整数分频模式:   类似f_out ≈ f_in/ (STEP + 1)
                                       *   - 分数分频模式:   类似f_out ≈ f_in * STEP/1024
                                       * (具体公式要看对应模块的数据手册, 但你可以把STEP理解为"分频档位值";)
                                       * 实战用法:
                                       *   - 你有个源时钟f_in(比如100 MHz), 想得到2 MHz的模块时钟;
                                       *   - 先选DM模式, 再根据公式反推STEP;
                                       *   - 把STEP写进去, 硬件会按这个系数自动生成接近的f_out; */
    Ifx_UReg_32Bit reserved_10:4;     /* [13:10] 保留位, 别动, 写0 */
    Ifx_UReg_32Bit DM:2;              /* [15:14] Divider Mode - DM(rw)
                                       * Divider Mode, 分频器工作模式选择:
                                       *   - DM = 00b:常见是"普通整数分频模式"(具体含义看该模块手册)
                                       *   - DM = 01b:分数分频模式(用STEP做f_out ≈ f_in * STEP/1024这种)
                                       *   - DM = 10b/11b:常用于关掉分频器或特殊测试模式(实际意义按手册)
                                       * 人话:
                                       *   - 想要"简单除以某个整数"→ 用整数模式;
                                       *   - 想要"搞一个除不尽的目标频率"(比如2.5MHz、1.8432MHz这类标准串口波特率基准)→ 用分数模式;
                                       */
    Ifx_UReg_32Bit RESULT:10;         /* [25:16] Result Value - RESULT(rh)
                                       * 这是"结果值", 只读;
                                       * 硬件根据你写的STEP和DM实际算出来、正在使用的分频系数/内部累加器值;
                                       * 作用:
                                       *   - 调完STEP之后, 读RESULT看"实际生效的内部设置";
                                       *   - 有些模式下, RESULT可能反映"有效分频比"或内部状态, 用于调试/校准;
                                       * 人话:
                                       *   - STEP是你"想要的值",
                                       *   - RESULT是"硬件最终采纳/运行中的值",
                                       *   - 偶尔会有'硬件对不合法STEP做了修正', 你就能从RESULT里看出来; */
    Ifx_UReg_32Bit reserved_26:5;     /* [30:26] 保留, 写0 */
    Ifx_UReg_32Bit DISCLK:1;          /* [31] Disable Clock - DISCLK(rwh)
                                       * 时钟输出总开关:
                                       *   - =1:关闭分频器输出(模块拿不到时钟, 相当于停机/省电)
                                       *   - =0:按STEP/DM/RESULT等配置正常输出时钟
                                       * 常见用途:
                                       *   - 上电初始化时, 先DISCLK=1, 先把STEP/DM配好, 再打开;
                                       *   - 低功耗模式下, 把不用的模块时钟关掉, 节省功耗;
                                       * 注意:某些模块的FDR是"模块本地"的(比如ASCLIN_FDR、QSPI_FDR、I2C_FDR),
                                       *       它们的DISCLK直接决定这个模块有没有时钟; */
} Ifx_SCU_FDR_Bits;


/* SCU Flag Modification Register(FMR):
 * 用"写1置位/写1清除"的方式, 给0~7号通道的INTFx标志打勾或擦掉;
 * 这是个只写寄存器, 专门用来改标志位, 不用读改写; */
typedef struct _Ifx_SCU_FMR_Bits
{
    Ifx_UReg_32Bit FS0:1;             /* [0] Set Flag INTFx for Channel 0 - FS0(w)
                                       * 写1: 把"通道0的INTF标志"置1; 写0: 什么都不干
                                       * 典型用法:
                                       *   - 软件模拟一次"通道0发生了事件"(强制置位标志)
                                       *   - 或在某些测试中, 手动触发对应的中断逻辑 */
    Ifx_UReg_32Bit FS1:1;             /* [1] 通道1: 写1置INTF1标志 */
    Ifx_UReg_32Bit FS2:1;             /* [2] 通道2: 写1置INTF2标志 */
    Ifx_UReg_32Bit FS3:1;             /* [3] 通道3: 写1置INTF3标志 */
    Ifx_UReg_32Bit FS4:1;             /* [4] 通道4: 写1置INTF4标志 */
    Ifx_UReg_32Bit FS5:1;             /* [5] 通道5: 写1置INTF5标志 */
    Ifx_UReg_32Bit FS6:1;             /* [6] 通道6: 写1置INTF6标志 */
    Ifx_UReg_32Bit FS7:1;             /* [7] 通道7: 写1置INTF7标志 */
    Ifx_UReg_32Bit reserved_8:8;      /* [15:8] 保留, 写0 */
    Ifx_UReg_32Bit FC0:1;             /* [16] Clear Flag INTFx for Channel 0 - FC0(w)
                                       *      写1: 把"通道0的INTF标志"清0
                                       *      写0: 不动作
                                       * 典型用法:
                                       *   - 在中断服务函数里, 处理完通道0事件后, 用它清除对应的中断标志
                                       *   - 用"写1清除", 避免读改写时被其它位抢占 */
    Ifx_UReg_32Bit FC1:1;             /* [17] 通道1: 写1清INTF1标志 */
    Ifx_UReg_32Bit FC2:1;             /* [18] 通道2: 写1清INTF2标志 */
    Ifx_UReg_32Bit FC3:1;             /* [19] 通道3: 写1清INTF3标志 */
    Ifx_UReg_32Bit FC4:1;             /* [20] 通道4: 写1清INTF4标志 */
    Ifx_UReg_32Bit FC5:1;             /* [21] 通道5: 写1清INTF5标志 */
    Ifx_UReg_32Bit FC6:1;             /* [22] 通道6: 写1清INTF6标志 */
    Ifx_UReg_32Bit FC7:1;             /* [23] 通道7: 写1清INTF7标志 */
    Ifx_UReg_32Bit reserved_24:8;     /* [31:24] 保留, 写0 */
} Ifx_SCU_FMR_Bits;

/* SCU模块"身份证"寄存器: 只读, 用来看这块SCU是啥型号、啥版本的 */
typedef struct _Ifx_SCU_ID_Bits
{
    Ifx_UReg_32Bit MODREV:8;          /* [7:0] Module Revision Number - MODREV(r)
                                       *  模块修订号(版本号)
                                       *  - 硬件IP自己的版本, 从0x00, 0x01, 0x02... 往上涨
                                       *  - 不同硅步进/不同代IP, 这个值可能不一样
                                       *  用途:
                                       *    - 启动时做"自诊断信息": 打印出SCU模块版本
                                       *    - 某些奇怪bug只在特定MODREV出现, 你可以在软件里:
                                       *        if(SCU_ID.B.MODREV < 某值)走兼容路径
                                       *      以避免踩到老版本设计缺陷 */
    Ifx_UReg_32Bit MODTYPE:8;         /* [15:8] Module Type - MODTYPE(r)
                                       *  模块类型标识(类型码)
                                       *  - 对SCU这种"系统控制单元"来说, 这个值一般固定, 比如0x00/0x01/0xC0之类
                                       *  - 用来区分"32bit模块/特定家族模块"等
                                       *  对应用层来说没啥需要手动判断的, 一般只是调试/识别用; */
    Ifx_UReg_32Bit MODNUMBER:16;      /* [31:16] Module Number - MODNUMBER(r)
                                       *  模块编号(Module ID)
                                       *  - 每种IP在Infineon的设计库里都有一个唯一编号
                                       *  - SCU会有自己的MODNUMBER, 比如0x0000/0x0044这一类(具体值看手册)
                                       *  用途:
                                       *    - 通用驱动/库可以通过MODNUMBER确认"这真的是SCU而不是别的模块"
                                       *    - 多个不同芯片共用一套代码时, 可根据MODNUMBER做轻微差异化处理(极少用到) */
} Ifx_SCU_ID_Bits;

/* SCU Flag Gating Register IGCRj:
 * 把ERU/外部事件的"标志位模式" → 映射成"生成事件/中断"的规则;
 * 简单说: 决定"哪些标志组合才算触发中断/事件", 做按位模式匹配 + 组合; */
typedef struct _Ifx_SCU_IGCR_Bits
{
    Ifx_UReg_32Bit IPEN00:1;          /* [0] Flag Pattern Enable for Channel 0 - IPEN00(rw)
                                       *  下面IPEN0x是"通道0"的8个pattern使能位(x = 0..7)
                                       *  这些位一一对应ERU/INFx上的某些标志位或输入位(具体映射看ERU/INTF章节的表);
                                       * 直观理解:
                                       *  - 通道0有一组"输入标志位数组"bit0..bit7,
                                       *  - IPEN00=1表示: 把这个bit0纳入"模式判断";
                                       *  - IPEN00=0表示: 忽略bit0, 不参与通道0的触发条件判断; */
    Ifx_UReg_32Bit IPEN01:1;          /* [1] 通道0 pattern bit1使能 */
    Ifx_UReg_32Bit IPEN02:1;          /* [2] 通道0 pattern bit2使能 */
    Ifx_UReg_32Bit IPEN03:1;          /* [3] 通道0 pattern bit3使能 */
    Ifx_UReg_32Bit IPEN04:1;          /* [4] 通道0 pattern bit4使能 */
    Ifx_UReg_32Bit IPEN05:1;          /* [5] 通道0 pattern bit5使能 */
    Ifx_UReg_32Bit IPEN06:1;          /* [6] 通道0 pattern bit6使能 */
    Ifx_UReg_32Bit IPEN07:1;          /* [7] 通道0 pattern bit7使能 */
    Ifx_UReg_32Bit reserved_8:5;      /* [12:8] 保留, 写0 */
    Ifx_UReg_32Bit GEEN0:1;           /* [13] Generate Event Enable 0 - GEEN0(rw)
                                       *  "通道0是否真正对外产生事件/中断"的总开关;
                                       *   =0: 即使pattern匹配了, 也不往外发事件(通道0逻辑关掉)
                                       *   =1: 允许通道0根据IGP0定义的规则产生事件/中断请求; */
    Ifx_UReg_32Bit IGP0:2;            /* [15:14] Interrupt Gating Pattern 0 - IGP0(rw)
                                       *  通道0的"模式组合方式", 2bit决定pattern匹配是怎么计算的;
                                       *  不同芯片文档略有区别, 一般常见风格类似:
                                       *    00b: 禁用/不考虑pattern(或直通单一路径)
                                       *    01b: 当"选中的IPEN0x bits中有任意一个为1"时触发(类似OR)
                                       *    10b: 当"选中的IPEN0x bits全部满足某条件"(类似AND)时触发
                                       *    11b: 保留或特殊模式(例如仅边沿触发)
                                       * 具体编码请对照SCU/ERU章节的IGCR表, 但核心概念就是:
                                       *   IGP0 = 决定"启用的IPEN0* 这些位之间是AND/OR/禁用/特殊逻辑"; */
    Ifx_UReg_32Bit IPEN10:1;          /* [16] Interrupt Pattern Enable for Channel 1 - IPEN10(rw)
                                       *  下面IPEN1x是"通道1"的8个pattern使能位, 与通道0一模一样, 只是对应另一组输入/标志; */
    Ifx_UReg_32Bit IPEN11:1;          /* [17] 通道1 pattern bit1使能 */
    Ifx_UReg_32Bit IPEN12:1;          /* [18] 通道1 pattern bit2使能 */
    Ifx_UReg_32Bit IPEN13:1;          /* [19] 通道1 pattern bit3使能 */
    Ifx_UReg_32Bit IPEN14:1;          /* [20] 通道1 pattern bit4使能 */
    Ifx_UReg_32Bit IPEN15:1;          /* [21] 通道1 pattern bit5使能 */
    Ifx_UReg_32Bit IPEN16:1;          /* [22] 通道1 pattern bit6使能 */
    Ifx_UReg_32Bit IPEN17:1;          /* [23] 通道1 pattern bit7使能 */
    Ifx_UReg_32Bit reserved_24:5;     /* [28:24] 保留, 写0 */
    Ifx_UReg_32Bit GEEN1:1;           /* [29] Generate Event Enable 1 - GEEN1(rw)
                                       *  通道1的事件生成总开关:
                                       *   =0: 通道1不对外产生事件/中断;
                                       *   =1: 允许通道1按照IGP1 + IPEN1* 的配置产生事件/中断; */
    Ifx_UReg_32Bit IGP1:2;            /* [31:30] Interrupt Gating Pattern 1 - IGP1(rw)
                                       *  通道1的模式组合控制, 与IGP0语义相同, 只是作用在通道1上;
                                       *  同样决定"启用的IPEN1* 组合起来, 是OR、AND还是其他特定模式"; */
} Ifx_SCU_IGCR_Bits;

/* ESR输入寄存器: 读"外部请求/复位引脚"的当前电平 */
typedef struct _Ifx_SCU_IN_Bits
{
    Ifx_UReg_32Bit P0:1;              /* [0] Input Bit 0 - P0(rh)
                                       *  只读, 表示"ESR0这路输入当前是高还是低";
                                       * 典型接法:
                                       *   - 板子上有个外部引脚(比如ESR0),
                                       *     可能接到了外部看门狗/PMIC/复位按钮等;
                                       *   - 当外部设备拉这个脚为某个电平(比如低电平),
                                       *     SCU_IN.B.P0就会反映这个状态;
                                       * 用处:
                                       *   - 软件想知道"外部复位/请求脚现在是啥状态";
                                       *   - 比如判断: 是外部芯片拉低ESR导致当前复位/唤醒,
                                       *     还是内部SMU自己触发的; */
    Ifx_UReg_32Bit P1:1;              /* [1] Input Bit 1 - P1(rh)
                                       *  同理, 是第二路ESR输入(ESR1)的当前电平;
                                       * 某些衍生型只实现ESR0或ESR1其中之一,
                                       * 另一路可能没用或固定值, 以数据手册为准;
                                       * 应用场景和P0一样:
                                       *   - 外接第二个复位/唤醒源时, 可以读P1看它当前状态; */
    Ifx_UReg_32Bit reserved_2:30;     /* [31:2] 保留位, 读出来别当真, 写也不能写 */
} Ifx_SCU_IN_Bits;

/* SCU_IOCR:ESR0/ESR1这两个"特殊脚"的方向/功能配置寄存器 */
typedef struct _Ifx_SCU_IOCR_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /* [3:0] 保留, 别动, 写0 */
    Ifx_UReg_32Bit PC0:4;             /* [7:4] Control for ESR0 Pin - PC0(rw)
                                       * 这是ESR0引脚的"模式选择/方向控制"字段(4bit);
                                       * TriCore/AURIX所有端口IOCR都是这套风格:
                                       *   PCx = 0b0000: 输入(带/不带上拉, 具体看该脚能力)
                                       *   PCx = 0b1000: 推挽输出
                                       *   PCx = 其它值: 某些特殊模式或保留(比如Open-Drain、替代功能)
                                       * 对ESR0来说, 手册通常给出几种典型值(伪举例, 实际编码请看SCU章节):
                                       *   0000b:ESR0作为"纯输入"(外部复位/请求脚)
                                       *   1000b:ESR0被SCU作为某种输出驱动(较少用, 一般ESR脚是输入)
                                       *   其它编码保留或不使用;
                                       * 实战上大部分场景:
                                       *   - 把ESR0当"外部复位/外部请求输入"用 → PC0配成输入模式;
                                       *   - 很少会把ESR0当普通GPIO输出用; */
    Ifx_UReg_32Bit reserved_8:4;      /* [11:8] 保留, 写0 */
    Ifx_UReg_32Bit PC1:4;             /* [15:12] Control for ESR1 Pin - PC1(rw)
                                       * 和PC0完全同一套语义, 只是作用在ESR1这个引脚上:
                                       *   - 作为第二路外部请求/复位输入;
                                       *   - 或极小概率场景下配置为输出/特殊功能;
                                       * 示例(逻辑层面):
                                       *   PC1 = 输入模式:ESR1用作第二路复位/请求脚;
                                       *   PC1 = 输出模式: 极少见, 除非手册注明可作某种特定输出; */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 其余位保留 */
} Ifx_SCU_IOCR_Bits;

/* SCU_LBISTCTRL0: 逻辑BIST(LBIST)启动/配置/状态寄存器
 * 用来在芯片内部跑一轮"给逻辑电路打自检"的伪随机测试(安全/FuSa用);
 * - 能配置要跑多少个测试Pattern
 * - 能发起LBIST
 * - 能看LBIST是否结束
 * - 能做"错误注入", 测试报警链路 */
typedef struct _Ifx_SCU_LBISTCTRL0_Bits
{
    Ifx_UReg_32Bit LBISTREQ:1;        /* [0] LBIST Request - LBISTREQ(w)
                                       *  写1: 请求执行一轮LBIST;
                                       *  写0: 无动作(这个位本身通常是"写1触发型", 不会永久保持);
                                       * 典型使用:
                                       *    - 在自检阶段(上电自检/周期性自测):
                                       *        1)配好PATTERNS(要跑多少个测试向量)
                                       *        2)写LBISTREQ=1发起逻辑BIST
                                       *        3)之后等LBISTDONE=1
                                       *  注意:
                                       *    - 这不是"随便按"的按钮, 一般只在安全框架规定的
                                       *      启动/停机/专用自检窗口里触发; */
    Ifx_UReg_32Bit LBISTRES:1;        /* [1] LBIST-Reset - LBISTRES(w)
                                       *  写1: 对LBIST控制逻辑做一次"内部复位";
                                       *  作用:
                                       *    - 清LBIST相关状态机/计数器,
                                       *    - 让LBIST处于"干净的起点", 方便重新发起测试;
                                       *  典型用法:
                                       *    - LBIST执行过程中出现异常/超时,
                                       *      或你希望重新跑一轮测试前, 先写LBISTRES=1做一次复位; */
    Ifx_UReg_32Bit PATTERNS:18;       /* [19:2] LBIST Pattern Number - PATTERNS(rw)
                                       *  配置LBIST要跑多少个测试Pattern(测试向量);
                                       *  人话:
                                       *    - LBIST实际上是往逻辑电路里打一堆伪随机向量,
                                       *      看最终MISR签名是否和预期匹配, 从而判断内部组合逻辑有没有
                                       *      "卡死/短路/断路"之类的故障;
                                       *    - PATTERNS就是"你打多少拳"的数字; 数字越大, 覆盖越好,
                                       *      但执行时间也越长;
                                       *  工程上:
                                       *    - 这个值一般不是凭空瞎填, 而是SoC厂商给定一个推荐值,
                                       *      能满足诊断覆盖率(DC)要求, 比如跑4096 pattern、8192 pattern等;
                                       *    - 你在安全配置表里会看到: 某个LBIST配置 = PATTERNS=N; */
    Ifx_UReg_32Bit reserved_20:8;     /* [27:20] 保留, 写0 */
    Ifx_UReg_32Bit LBISTDONE:1;       /* [28] LBIST Execution Indicator - LBISTDONE(rh)
                                       *  LBIST执行完成指示(只读状态位);
                                       *  =0:LBIST还在执行/尚未启动;
                                       *  =1:LBIST执行完一轮(无论结果PASS/FAIL, 这个位仅表示"跑完了");
                                       *  典型逻辑:
                                       *    - 写LBISTREQ=1之后, 在某个自检阶段轮询这个位:
                                       *        while(SCU_LBISTCTRL0.B.LBISTDONE == 0) { // 等测试跑完 }
                                       *    - 跑完后, 再去读"结果寄存器/错误标志"(在别的LBIST状态寄存器里)
                                       *      判断这轮BIST是Pass还是Fail; */
    Ifx_UReg_32Bit reserved_29:1;     /* [29] 保留 */
    Ifx_UReg_32Bit LBISTERRINJ:1;     /* [30] LBIST/Test-Mode Alarm Error Injection - LBISTERRINJ(rwh)
                                       *  错误注入开关: 用于测试"报警链路是否可靠";
                                       *  人话:
                                       *    - 正常LBIST如果芯片没问题, 会得到一个"正确签名" → PASS;
                                       *    - 某些安全需求要求:
                                       *        "不仅要检测真故障, 还要定期验证**检测机制本身**是好的;"
                                       *    - 打开LBISTERRINJ时, LBIST会被故意"扰一下",
                                       *      让结果变成FAIL, 从而触发SMU或安全报警路径;
                                       *  用法场景:
                                       *    - FuSa自检: 在某些特定Test Mode下, 设置LBISTERRINJ=1,
                                       *      发起LBIST, 检查是否:
                                       *         - 错误被正确发现,
                                       *         - SMU/Fault Collection/报警机制按安全概念设计那样动作;
                                       *  属性rwh:
                                       *    - 读: 看当前是否处于"错误注入模式";
                                       *    - 写: 一般写1打开, 写0关闭, 写法按手册建议; */
    Ifx_UReg_32Bit LBISTREQRED:1;     /* [31] LBIST Request Redundancy - LBISTREQRED(rw)
                                       *  LBIST请求冗余位, 用于安全防护(避免单点写错就起BIST);
                                       *  典型模式(概念):
                                       *    - 某些FuSa设计中要求:
                                       *        - 发起一类"重动作"(比如跑LBIST/改变安全状态)时,
                                       *          不能只依赖一个单一比特(LBISTREQ);
                                       *        - 要有第二个冗余bit配合, 硬件检查两者是否满足特定关系
                                       *          (例如: 必须LBISTREQ=1且LBISTREQRED=1才真正起BIST),
                                       *          以防"单比特翻转导致误触发";
                                       *  实际编码规则要看手册:
                                       *    - 有的要求写两个特定值序列;
                                       *    - 有的只要求两位同时置1;
                                       *  但大意就是: 这是为LBISTREQ提供的"冗余确认位",
                                       *  用在安全应用中提升对控制路径故障的防护程度; */
} Ifx_SCU_LBISTCTRL0_Bits;

/* SCU_LBISTCTRL1: 配置LBIST"怎么玩"的高级参数:
 * - 用哪个随机种子(SEED)
 * - 怎么split/shift(SPLITSH)
 * - 是"车身应用"还是"其他域"(BODY)
 * - 用多快的测试时钟跑LBIST(LBISTFREQU) */
typedef struct _Ifx_SCU_LBISTCTRL1_Bits
{
    Ifx_UReg_32Bit SEED:19;           /* [18:0] LBIST Seed - SEED(rw)
                                       * 这是LBIST的"随机种子";
                                       * LBIST内部用一个PRPG(伪随机模式发生器)往逻辑里打各种0/1组合,
                                       * 这个SEED就是PRPG的起始值;
                                       * 人话:
                                       *   - 同样的SEED + PATTERNS → 产生同样的一串测试向量,
                                       *     对应一个"预期签名"(Golden Signature);
                                       *   - 换一个SEED, 就相当于"从另一组随机序列角度去测试逻辑",
                                       *     可以提高诊断覆盖率(多轮自检);
                                       * 工程上:
                                       *   - SoC供应商通常给出默认SEED, 用于标准LBIST运行;
                                       *   - 如果安全概念要求"多次LBIST, 各用不同SEED",
                                       *     可以在BODY=0/1或不同测试周期里切不同SEED; */
    Ifx_UReg_32Bit reserved_19:5;     /* [23:19] 保留, 写0 */
    Ifx_UReg_32Bit SPLITSH:3;         /* [26:24] LBIST Split-Shift Selection - SPLITSH(rw)
                                       * "Split-Shift"选择: 决定LBIST在逻辑上的"分段/移位方式";
                                       * 背景:
                                       *   - 复杂SoC里, LBIST不一定一次全网打通,
                                       *     而是把逻辑分成几块(split), 分不同相位/shift进行测试;
                                       *   - SPLITSH就是告诉LBIST控制器:
                                       *       "这次LBIST是按哪种split/shift策略来扫逻辑;"
                                       * 概念上你可以理解为:
                                       *   - 000b: 默认split/shift方案(覆盖某一批逻辑)
                                       *   - 001b: 第二种划分/移位方式
                                       *   - ...
                                       *   (具体含义要看芯片的LBIST专门文档)
                                       * 工程用途:
                                       *   - 配合SEED和PATTERNS, 可以做"多轮LBIST、每轮覆盖不同逻辑区域/不同移位方案";
                                       *   - 安全概念里常写: 周期性执行LBIST, 轮换不同SPLITSH值以提升累积诊断覆盖率; */
    Ifx_UReg_32Bit BODY:1;            /* [27] Body Application Indicator - BODY(rw)
                                       * "Body应用指示"——区分当前LBIST针对的是哪一类应用/域;
                                       * 人话理解:
                                       *   - 有的AURIX/车规芯片里, 会区分:
                                       *       - "Body域(车身应用)"
                                       *       - "其他域(比如动力/安全岛)"
                                       *   - BODY位通常用来:
                                       *       - 控制:LBIST针对哪个逻辑区域/签名集;
                                       *       - 或在诊断报告中区分"当前测试的是body部分"还是别的域;
                                       * 工程上:
                                       *   - 这个位一般会在FuSa配置表中由供应商规定,
                                       *     比如BODY=1表示"按车身应用配置跑LBIST", BODY=0表示"按其他域配置";
                                       *   - 应用层通常只需照安全手册设定, 不会随意切换; */
    Ifx_UReg_32Bit LBISTFREQU:4;      /* [31:28] LBIST Frequency Selection - LBISTFREQU(rw)
                                       * LBIST运行频率选择: 决定测试时的"时钟快慢";
                                       * 背景:
                                       *   - LBIST可以用不同的测试时钟频率跑:
                                       *       - 太快 → 能测试出时序边界问题, 但可能越界到不安全区;
                                       *       - 太慢 → 安全余量大, 但"过于温和", 某些边界问题测不出来;
                                       *   - 同时, 速度也影响测试时长: 频率高 → PATTERNS跑完更快;
                                       * LBISTFREQU的4bit一般会对应若干离散等级(例如分频比、选择不同test clock源):
                                       *   - 0000b: 最低频LBIST时钟
                                       *   - 0001b: 略高一点
                                       *   - ...
                                       *   (具体频点映射要看SCU/LBIST小节的表)
                                       * 工程用途:
                                       *   - 在冷启动阶段, 可能用一个相对低的LBIST频率(稳定优先);
                                       *   - 在周期性在线自测时, 根据系统负载选择适当的频率折中"覆盖率vs时间"; */
} Ifx_SCU_LBISTCTRL1_Bits;

/* LBISTCTRL2: 配置/查看"最长扫描链长度"的寄存器 */
typedef struct _Ifx_SCU_LBISTCTRL2_Bits
{
    Ifx_UReg_32Bit LENGTH:12;         /* [11:0] LBIST Maximum Scan-Chain Length - LENGTH(rwh)
                                       * 这是LBIST的"最大扫描链长度"配置/状态;
                                       * 背景:
                                       *   - LBIST本质上是把一大片逻辑串在若干条scan-chain里面,
                                       *     然后把伪随机比特沿着链推过去, 看最后的签名是否匹配;
                                       *   - LENGTH表示在这次LBIST配置下, 每条scan-chain要"串"多长;
                                       * rwh(读/写/硬件可改)说明:
                                       *   - 写: 配置最大链长(具体值通常由芯片厂给出建议, 不是瞎填);
                                       *   - 读: 可以看到当前使用的长度(有些实现中硬件会根据实际资源修正);
                                       * 工程上:
                                       *   - 一般不会自己乱改, 按照安全手册或参考代码配置;
                                       *   - 若要做高级诊断/调试, 可以读这个值, 确认当前LBIST是按哪个链长在跑; */
    Ifx_UReg_32Bit reserved_12:20;    /* [31:12] 保留, 写0 */
} Ifx_SCU_LBISTCTRL2_Bits;

/* LBISTCTRL3:LBIST产生的"签名" */
typedef struct _Ifx_SCU_LBISTCTRL3_Bits
{
    Ifx_UReg_32Bit SIGNATURE:32;      /* [31:0] LBIST Signature - SIGNATURE(rh)
                                       * 这是LBIST测试结束后的"结果签名"(只读);
                                       * 背景:
                                       *   - LBIST把一大堆输出响应压到一个MISR(多项式寄存器)里,
                                       *     形成一个32bit的"压缩结果", 就像一个哈希值;
                                       *   - 如果芯片内部逻辑正确、没有故障, 那么在给定的SEED/PATTERNS/
                                       *     SPLITSH/FREQU下, SIGNATURE应该等于一个"黄金签名(Golden Signature)";
                                       * 用法:
                                       *   1)LBIST配置好 → 发起LBISTREQ → 等LBISTDONE=1;
                                       *   2)读SIGNATURE;
                                       *   3)和期望值(从数据手册/安全文档/厂商工具生成)对比:
                                       *        - 一样 → PASS
                                       *        - 不一样 → FAIL(逻辑有问题或者配错)
                                       * 概念上:
                                       *   - 它不是"错误标志", 而是用来和Golden Signature比较的"指纹"; */
} Ifx_SCU_LBISTCTRL3_Bits;

/* LCLCON0:Lockstep控制/状态寄存器(CPU0 & CPU2) */
typedef struct _Ifx_SCU_LCLCON0_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0] 保留 */
    Ifx_UReg_32Bit reserved_1:14;     /* [14:1] 保留 */
    Ifx_UReg_32Bit reserved_15:1;     /* [15] 保留 */
    Ifx_UReg_32Bit LS0:1;             /* [16] Lockstep Mode Status - LS0(rh)
                                       * CPU0/CPU2的lockstep状态指示(只读);
                                       * Lockstep是啥?
                                       *   - 简单说: 两颗核(比如CPU0和CPU1/CPU2)执行同一份指令流,
                                       *     每个周期比较结果, 如果有差异就认为发生故障;
                                       *   - 这是安全芯片上用来防范CPU计算错误的一种硬件冗余方式;
                                       * LS0 = 1: 当前Lockstep模式"已激活"(对应的lockstep对工作中)
                                       * LS0 = 0: 当前没有处于lockstep模式(可能是单核独立运行)
                                       * 用法:
                                       *   - 启动之后, 读LS0来确认锁步是否真的拉起来了;
                                       *   - 如果LSEN0=1但LS0=0 → 说明配置/硬件有问题, 需要诊断; */
    Ifx_UReg_32Bit reserved_17:14;    /* [30:17] 保留 */
    Ifx_UReg_32Bit LSEN0:1;           /* [31] Lockstep Enable - LSEN0(rw)
                                       * Lockstep使能控制位(读写):
                                       *   - 写1: 使能CPU0相关的Lockstep功能(具体配对哪个核要看芯片结构,
                                       *           例如CPU0/CPU1或CPU0/CPU2做锁步);
                                       *   - 写0: 关闭Lockstep(对应核单独运行);
                                       * 工程注意:
                                       *   - 开关Lockstep通常不在普通应用里动态乱切, 通常在启动阶段配置好后常驻;
                                       *   - 某些芯片要求在特定模式下才能改LSEN0(例如只有在复位/安全模式下设置),
                                       *     否则会被拒绝或触发SMU报告;
                                       *   - 安全文档上会明确: 对于ASIL-D核, LSEN0必须=1,
                                       *     不允许在运行期随便关掉; */
} Ifx_SCU_LCLCON0_Bits;

/* LCLCON1:CPU1 & CPU3的Lockstep控制/状态寄存器 */
typedef struct _Ifx_SCU_LCLCON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0] 保留 */
    Ifx_UReg_32Bit reserved_1:14;     /* [14:1] 保留 */
    Ifx_UReg_32Bit reserved_15:1;     /* [15] 保留 */
    Ifx_UReg_32Bit LS1:1;             /* [16] Lockstep Mode Status - LS1(rh)
                                       * 和LCLCON0.LS0一样, 只不过对应另一组Lockstep对(CPU1/CPU3这组);
                                       * LS1 = 1: 说明对应的Lockstep模式已经实际启用、
                                       *           两个核正在锁步执行;
                                       * LS1 = 0: 说明没有在锁步模式(当前组处于独立运行);
                                       * 用法:
                                       *   - 启动配置时, 设LSEN1后, 读LS1确认锁步状态确实"拉起来"了;
                                       *   - 安全监控: 如果期望锁步=ON, 而LS1=0, 则视为配置错误或硬件故障; */
    Ifx_UReg_32Bit reserved_17:14;    /* [30:17] 保留 */
    Ifx_UReg_32Bit LSEN1:1;           /* [31] Lockstep Enable - LSEN1(rw)
                                       * Lockstep使能位(这次是对CPU1/CPU3那一组):
                                       *   写1: 请求启用这组lockstep;
                                       *   写0: 关闭这组lockstep(两个核独立跑);
                                       * 同样注意:
                                       *   - 改这个位通常受安全约束(比如只允许在特定模式/复位阶段改);
                                       *   - 在ASIL-D项目里, 一旦lockstep打开, 运行期通常不会再关掉; */
} Ifx_SCU_LCLCON1_Bits;

/* LCLTEST:Lockstep"自测触发"寄存器 */
typedef struct _Ifx_SCU_LCLTEST_Bits
{
    Ifx_UReg_32Bit LCLT0:1;           /* [0] LCL0 Lockstep Test - LCLT0(w)
                                       * 给Lockstep0(比如CPU0配对)做"测试触发"的控制位;
                                       * 写1: 触发一次Lockstep测试(具体行为按手册, 一般为:
                                       *     故意制造一次比较差异/检查报警路径);
                                       * 人话:
                                       *   - 锁步本质上是两个核做比较,
                                       *   - LCLT0=1就是"故意在LCL0这路做一次异常, 让你看看SMU/报警是否工作"; */
    Ifx_UReg_32Bit LCLT1:1;           /* [1] LCL1 Lockstep Test - LCLT1(w)
                                       *  同上, 对Lockstep1(CPU1/CPU3对)做测试触发; */
    Ifx_UReg_32Bit LCLT2:1;           /* [2] LCL2 Lockstep Test - LCLT2(w)
                                       *  某些芯片有更多lockstep对(比如安全岛核), LCLT2/LCLT3对应它们; */
    Ifx_UReg_32Bit LCLT3:1;           /* [3] LCL3 Lockstep Test - LCLT3(w) */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit reserved_5:1;      /* [5] 保留 */
    Ifx_UReg_32Bit reserved_6:10;     /* [15:6] 保留 */
    Ifx_UReg_32Bit PLCLT0:1;          /* [16] PFI0 Lockstep Test(w)
                                       * PLCLT0~3: 针对Program Flash Interface(PFI0..3)的Lockstep测试触发;
                                       * - 写1: 对对应的PFI做一次lockstep自检(类似CPU lockstep test,
                                       *   但对象是在访问Flash的接口模块);
                                       * 用来验证:
                                       *   - PFI lockstep比较逻辑是否正常;
                                       *   - SMU/错误报告路径对PFI lockstep故障的响应是否符合安全设计; */
    Ifx_UReg_32Bit PLCLT1:1;          /* [17] PFI1 Lockstep Test(w) */
    Ifx_UReg_32Bit PLCLT2:1;          /* [18] PFI2 Lockstep Test(w) */
    Ifx_UReg_32Bit PLCLT3:1;          /* [19] PFI3 Lockstep Test(w) */
    Ifx_UReg_32Bit reserved_20:1;     /* [20] 保留 */
    Ifx_UReg_32Bit reserved_21:1;     /* [21] 保留 */
    Ifx_UReg_32Bit reserved_22:10;    /* [31:22] 保留 */
} Ifx_SCU_LCLTEST_Bits;

/* MANID: 芯片厂商/部门"身份码" */
typedef struct _Ifx_SCU_MANID_Bits
{
    Ifx_UReg_32Bit DEPT:5;            /* [4:0] Department Identification Number - DEPT(r)
                                       * 部门ID(哪个部门设计/维护这个IP);
                                       * 对普通应用没实际用处, 主要用于内部识别:
                                       *   - Infineon内部区分负责该模块的设计团队;
                                       *   - 调试/FA时用于快速定位模块来源; */
    Ifx_UReg_32Bit MANUF:11;          /* [15:5] Manufacturer Identification Number - MANUF(r)
                                       * 厂商ID(Manufacturer ID);
                                       * - 对Infineon芯片来说, 这里会有一个固定的厂商编码;
                                       * - 在一些标准/协议中, 用这个值识别"是哪个厂制造的逻辑IP/芯片";
                                       * 应用层一般不会用到, 只是调试/信息展示用; */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_MANID_Bits;

/* ESR Output Modification Register: 用"写1置位/写1清零"的方式控制ESR0/ESR1输出 */
typedef struct _Ifx_SCU_OMR_Bits
{
    Ifx_UReg_32Bit PS0:1;             /* [0] ESRx Pin Set Bit 0 - PS0(w)
                                       * "Pin Set"——给ESR0输出脚置位(写1生效);
                                       * 前提:ESR0必须被配置成输出模式(通过IOCR.PC0);
                                       * 语义:
                                       *   - 写1: 把ESR0输出置为'1';
                                       *   - 写0: 不影响该位;
                                       * 优势:
                                       *   - 不用读-改-写某个OUT寄存器, 而是"写1即置位", 不会误伤其他位; */
    Ifx_UReg_32Bit PS1:1;             /* [1] ESRx Pin Set Bit 1 - PS1(w)
                                       * 同理, 用于ESR1输出:
                                       *   - 写1: 把ESR1输出置为'1'; */
    Ifx_UReg_32Bit reserved_2:14;     /* [15:2] 保留 */
    Ifx_UReg_32Bit PCL0:1;            /* [16] ESRx Pin Clear Bit 0 - PCL0(w)
                                       * "Pin Clear"——给ESR0输出脚清零(写1生效);
                                       * 语义:
                                       *   - 写1: 把ESR0输出置为'0';
                                       *   - 写0: 不动作;
                                       * PS0/PCL0组合起来, 就能用"写1置位/写1清零"的方式控制ESR0; */
    Ifx_UReg_32Bit PCL1:1;            /* [17] ESRx Pin Clear Bit 1 - PCL1(w)
                                       * 同理, 用于ESR1输出:
                                       *   - 写1: 把ESR1输出拉'0'; */
    Ifx_UReg_32Bit reserved_18:14;    /* [31:18] 保留 */
} Ifx_SCU_OMR_Bits;


/* OSC Control Register */
typedef struct _Ifx_SCU_OSCCON_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0:0] internal Reserved */
    Ifx_UReg_32Bit PLLLV:1;           /* [1:1] 振荡是否"振好了"的两个状态灯: PLLLV/PLLHV (rh) */
    Ifx_UReg_32Bit OSCRES:1;          /* [2:2] 给"晶振看门狗"按一下reset, 清状态、重启监控 (w) */
    Ifx_UReg_32Bit GAINSEL:2;         /* [4:3] 控制晶振模拟放大器的"增益档位"——用多大的力推晶体振起来 (rw) */
    Ifx_UReg_32Bit MODE:2;            /* [6:5] 决定外部晶振这路电路工作在哪种模式 (rw) */
    Ifx_UReg_32Bit SHBY:1;            /* [7:7] 要不要绕过"波形整形器" (rw) */
    Ifx_UReg_32Bit PLLHV:1;           /* [8:8] 振荡是否"振好了"的两个状态灯: PLLLV/PLLHV (rh) */
    Ifx_UReg_32Bit HYSEN:1;           /* [9:9] 开启"迟滞"——简单理解为给比较器加点"抗抖保护" (rw) */
    Ifx_UReg_32Bit HYSCTL:2;          /* [11:10] 调迟滞的大小, 类似于"灵敏度" (rw) */
    Ifx_UReg_32Bit AMPCTL:2;          /* [13:12] 细化振幅控制策略, 例如启动时先用大幅度, 稳定后降低等 (rw) */
    Ifx_UReg_32Bit reserved_14:2;     /* [15:14] internal Reserved */
    Ifx_UReg_32Bit OSCVAL:5;          /* [20:16] 用来把晶振频率fOSC分成"看门狗参考频率fOSCREF", 通常选到 ~2.5MHz (rw) */
    Ifx_UReg_32Bit reserved_21:2;     /* [22:21] internal Reserved */
    Ifx_UReg_32Bit APREN:1;           /* [23:23] 使能振幅自动调节 (rw) */
    Ifx_UReg_32Bit CAP0EN:1;          /* [24:24] 给晶振引脚接不接"片内负载电容"的开关 (rw) */
    Ifx_UReg_32Bit CAP1EN:1;          /* [25:25] 给晶振引脚接不接"片内负载电容"的开关 (rw) */
    Ifx_UReg_32Bit CAP2EN:1;          /* [26:26] 给晶振引脚接不接"片内负载电容"的开关 (rw) */
    Ifx_UReg_32Bit CAP3EN:1;          /* [27:27] 给晶振引脚接不接"片内负载电容"的开关 (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /* [31:28] internal Reserved */
} Ifx_SCU_OSCCON_Bits;

/* ESR Output Register: 直接读/写ESR0/ESR1输出latch(配合IOCR/OMR使用) */
typedef struct _Ifx_SCU_OUT_Bits
{
    Ifx_UReg_32Bit P0:1;              /* [0] Output Bit 0 - P0(rwh)
                                       * ESR0引脚对应的输出latch;
                                       * - 读: 看到当前"软件想要ESR0输出的逻辑值"(不是一定等于管脚电平, 受IOCR/PDISC/外部因素影响);
                                       * - 写:
                                       *     P0=1: 把ESR0输出latch置1;
                                       *     P0=0: 把ESR0输出latch置0;
                                       *   前提:IOCR.PC0已配成输出模式;
                                       * 一般不建议用"直接写OUT"的方式改位,
                                       * 更推荐用OMR的PSx/PCLx(写1置位/清零), 避免读改写竞态; */
    Ifx_UReg_32Bit P1:1;              /* [1] Output Bit 1 - P1(rwh)
                                       * ESR1对应的输出latch, 与P0同理; */
    Ifx_UReg_32Bit reserved_2:30;     /* [31:2] 保留, 写0, 读了别当真 */
} Ifx_SCU_OUT_Bits;

/* OVCCON:Overlay总控制寄存器(选CPU、启动/停止overlay、配写保护) */
typedef struct _Ifx_SCU_OVCCON_Bits
{
    Ifx_UReg_32Bit CSEL0:1;           /* [0] CPU Select 0 - CSEL0(w)
                                       * 选择"下一个Overlay操作"针对哪颗CPU;
                                       * 一般用法:
                                       *   - 写1到对应的CSELx: 选中某个CPU为overlay的目标,
                                       *   - 然后用OVSTRT/OVSTP等位发起"启用/停止overlay"的命令;
                                       * 注意: 这些是"写动作位", 不是永久保持的状态; */
    Ifx_UReg_32Bit CSEL1:1;           /* [1] CPU Select 1(If product has CPU1) - CSEL1(w)
                                       *  针对CPU1的选择位(同上); */
    Ifx_UReg_32Bit CSEL2:1;           /* [2] CPU Select 2(If product has CPU2) - CSEL2(w) */
    Ifx_UReg_32Bit CSEL3:1;           /* [3] CPU Select 3(If product has CPU3) - CSEL3(w) */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit reserved_5:1;      /* [5] 保留 */
    Ifx_UReg_32Bit reserved_6:10;     /* [15:6] 保留 */
    Ifx_UReg_32Bit OVSTRT:1;          /* [16] Overlay Start - OVSTRT(w)
                                       * 写1: 对"当前选中的CPU(由CSELx指定)"启动overlay;
                                       * overlay是什么?
                                       *   - 一种"地址重映射"机制: 把某段逻辑地址区间映射到另一块物理存储(比如把PFlash上的一段代码
                                       *     "覆盖"为RAM中的调试版本), 对CPU来说地址没变, 但实际执行的是新内容;
                                       * 通常步骤:
                                       *   1)配overlay区间、目标存储等(在别的OVCx寄存器里);
                                       *   2)写CSELx选中CPU;
                                       *   3)写OVSTRT=1发起overlay启动; */
    Ifx_UReg_32Bit OVSTP:1;           /* [17] Overlay Stop - OVSTP(w)
                                       * 写1: 对当前选中的CPU停止overlay(恢复原始映射);
                                       * 可以用来:
                                       *   - 启动/停止调试overlay;
                                       *   - 在安全事件后强制退出overlay, 恢复到只执行PFlash正式代码; */
    Ifx_UReg_32Bit DCINVAL:1;         /* [18] Data Cache Invalidate - DCINVAL(w)
                                       * 写1: 触发"数据Cache失效(invalidate)";
                                       * 场景:
                                       *   - 当overlay涉及RAM/Flash映射变更时, 可能已经缓存的旧数据/代码不再有效;
                                       *   - 这时需要手动invalidation, 确保不会读到旧cache line;
                                       * 这一般配合OVSTRT/OVSTP一起使用, 做一次干净切换; */
    Ifx_UReg_32Bit reserved_19:5;     /* [23:19] 保留 */
    Ifx_UReg_32Bit OVCONF:1;          /* [24] Overlay Configured - OVCONF(rw)
                                       * Overlay配置状态标志:
                                       *   - 写1: 表示"Overlay配置已经完成/启用",
                                       *   - 写0: 表示"Overlay未配置或已禁用";
                                       * 有些芯片会要求:
                                       *   - 只有OVCONF=1时, 某些overlay配置寄存器才会生效;
                                       *   - 或安全软件可以根据OVCONF是否为1来判断是否允许执行某类overlay代码; */
    Ifx_UReg_32Bit POVCONF:1;         /* [25] Write Protection for OVCONF - POVCONF(w)
                                       * 对OVCONF的写保护:
                                       *   - 一旦对POVCONF写1, OVCONF的写访问会变得受限(只能按照特定序列修改);
                                       * 用途:
                                       *   - 防止运行期误写/攻击者修改overlay状态;
                                       *   - 在安全项目中, 通常在完成overlay初始化后, 通过这个位锁定OVCONF, 增强安全性; */
    Ifx_UReg_32Bit reserved_26:6;     /* [31:26] 保留 */
} Ifx_SCU_OVCCON_Bits;

/* OVCENABLE: 对每个CPU单独打开/关闭overlay功能 */
typedef struct _Ifx_SCU_OVCENABLE_Bits
{
    Ifx_UReg_32Bit OVEN0:1;           /* [0] Overlay Enable 0 - OVEN0(rw)
                                       * 针对CPU0的overlay全局开关:
                                       *   - =1: 允许CPU0使用overlay映射(在OV区域配置好的情况下);
                                       *   - =0:CPU0总是看到原始映射(不走overlay);
                                       * 一般流程:
                                       *   - 配好overlay区间;
                                       *   - 打开OVEN0;
                                       *   - 再用OVSTRT/OVSTP控制具体的启停; */
    Ifx_UReg_32Bit OVEN1:1;           /* [1] Overlay Enable 1(If product has CPU1) - OVEN1(rw)
                                       *  同理, 控制CPU1的overlay使能; */
    Ifx_UReg_32Bit OVEN2:1;           /* [2] Overlay Enable 2(If product has CPU2) - OVEN2(rw) */
    Ifx_UReg_32Bit OVEN3:1;           /* [3] Overlay Enable 3(If product has CPU3) - OVEN3(rw) */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit reserved_5:1;      /* [5] 保留 */
    Ifx_UReg_32Bit reserved_6:26;     /* [31:6] 保留 */
} Ifx_SCU_OVCENABLE_Bits;

/* PDISC:Pad Disable Control: 是否让ESR0/ESR1这个管脚"物理断开" */
typedef struct _Ifx_SCU_PDISC_Bits
{
    Ifx_UReg_32Bit PDIS0:1;           /* [0] Pad Disable for ESR Pin 0 - PDIS0(rw)
                                       * =1: 禁用ESR0 pad(管脚物理断开)——
                                       *      - 外部看不到驱动;
                                       *      - 内部不再从该管脚采样;
                                       *      - 一般相当于"对这个pad做隔离", 用在特殊低功耗/测试模式;
                                       * =0: 正常连接ESR0 pad;
                                       * 用途:
                                       *   - 极端低功耗: 关掉某些pad, 减少泄漏;
                                       *   - 某些板子没有使用ESR0, 可以在系统安全配置中选择把它disable掉; */
    Ifx_UReg_32Bit PDIS1:1;           /* [1] Pad Disable for ESR Pin 1 - PDIS1(rw)
                                       *  同理, 对ESR1 pad进行禁用/使能控制; */
    Ifx_UReg_32Bit reserved_2:30;     /* [31:2] 保留 */
} Ifx_SCU_PDISC_Bits;

/* PDR:ESR引脚的Pad驱动模式/电平标准配置 */
typedef struct _Ifx_SCU_PDR_Bits
{
    Ifx_UReg_32Bit PD0:2;             /* [1:0] Pad Driver Mode for ESR Pins 0 - PD0(rw)
                                       * 驱动模式: 强弱驱动、上升下降沿速度等;
                                       * 典型编码(逻辑上的理解, 具体值看datasheet):
                                       *   00b: 最弱驱动, 沿最慢(EMI最小, 适合长线/敏感环境);
                                       *   01b: 中等驱动;
                                       *   10b: 强驱动;
                                       *   11b: 保留或更强/更快模式;
                                       * 对于接外部PMIC/Reset控制线的ESR0,
                                       * 一般会选一个合适的驱动强度, 避免过猛/过软; */
    Ifx_UReg_32Bit PL0:2;             /* [3:2] Pad Level Selection for ESR Pins 0 - PL0(rw)
                                       * 电平标准选择, 例如Automotive Level/TTL Level等;
                                       *   - 例如:
                                       *       00b:Automotive level(宽阈值, 抗噪声);
                                       *       01b:TTL/CMOS Level(更接近逻辑电路阈值);
                                       *   实际编码以芯片手册为准;
                                       * 工程含义:
                                       *   - 连到车身线束、外部硬件环境复杂 → 选AL(汽车级电平, 更抗干扰);
                                       *   - 连到另一个数字芯片、3.3V逻辑 → 选TTL/CMOS Level; */
    Ifx_UReg_32Bit PD1:2;             /* [5:4] Pad Driver Mode for ESR Pins 1 - PD1(rw)
                                       * ESR1的驱动强度/边沿速度设置, 语义同PD0; */
    Ifx_UReg_32Bit PL1:2;             /* [7:6] Pad Level Selection for ESR Pins 1 - PL1(rw)
                                       * ESR1的电平标准设置, 语义同PL0; */
    Ifx_UReg_32Bit reserved_8:24;     /* [31:8] 保留 */
} Ifx_SCU_PDR_Bits;

/* PDRR:Pattern Detection Result Register
 * 读"模式检测结果"的状态灯, 每个通道一个bit;
 */
typedef struct _Ifx_SCU_PDRR_Bits
{
    Ifx_UReg_32Bit PDR0:1;            /* [0] Pattern Detection Result of Channel 0 - PDR0(rh)
                                       * 通道0的"模式检测结果":
                                       *   =1: 说明通道0上配置的pattern(通过IGCR/IPEN/IGP那套)当前匹配成功;
                                       *   =0: 当前未匹配;
                                       * 这是一盏只读小灯, 用于调试/监控:
                                       *   - 你配好SCU ERU/IGCR模式后, 可以读PDR0看通道0有没有"被认为满足触发条件"; */
    Ifx_UReg_32Bit PDR1:1;            /* [1] 通道1模式匹配结果 */
    Ifx_UReg_32Bit PDR2:1;            /* [2] 通道2模式匹配结果 */
    Ifx_UReg_32Bit PDR3:1;            /* [3] 通道3模式匹配结果 */
    Ifx_UReg_32Bit PDR4:1;            /* [4] 通道4模式匹配结果 */
    Ifx_UReg_32Bit PDR5:1;            /* [5] 通道5模式匹配结果 */
    Ifx_UReg_32Bit PDR6:1;            /* [6] 通道6模式匹配结果 */
    Ifx_UReg_32Bit PDR7:1;            /* [7] 通道7模式匹配结果 */
    Ifx_UReg_32Bit reserved_8:24;     /* [31:8] 保留 */
} Ifx_SCU_PDRR_Bits;

/* PERPLLCON0: 外设PLL配置0(P/N分频 + 省电模式 + 重新锁定) */
typedef struct _Ifx_SCU_PERPLLCON0_Bits
{
    Ifx_UReg_32Bit DIVBY:1;           /* [0] Divider Bypass - DIVBY(rw)
                                       * 外设PLL的"额外除数开关", 不同芯片里用于控制
                                       * fPLL2是否有一个额外的/1.6或/2之类的固定分频;
                                       * 常见用途:
                                       *   - =0: 使用额外分频(例如fPLL2 = fVCO/ (K3 * 1.6)之类)
                                       *   - =1:Bypass这一级(fPLL2 = fVCO/K3)
                                       * 实际公式要看datasheet的PERPLL时钟树,
                                       * BSP里通常通过UC_PLL1_DIVBY之类的宏给出推荐值; */
    Ifx_UReg_32Bit reserved_1:8;      /* [8:1] 保留 */
    Ifx_UReg_32Bit NDIV:7;            /* [15:9] N-Divider Value - NDIV(rw)
                                       * VCO的倍频因子N:
                                       *   fVCO = fIN * NDIV/PDIV
                                       * 你在bsp_uc_scu_EnablePLL1(pdiv, ndiv, ...)里传进来的ndiv
                                       * 就是写到这里;
                                       * 注意:
                                       *   - 不同NDIV范围要符合:
                                       *       1)fIN在 [INCLK_MIN, INCLK_MAX]
                                       *       2)fVCO在 [VCO_MIN, VCO_MAX]
                                       *   - 这几个边界前面PLL1 SPEC宏已经帮你定义了; */
    Ifx_UReg_32Bit PLLPWD:1;          /* [16] Peripheral PLL Power Saving Mode - PLLPWD(rw)
                                       * 外设PLL1的"省电/关机开关":PWD = PowerDown;
                                       *   - =1:PLL正常工作(上电, 进行锁相);
                                       *   - =0:PLL进入省电模式(关机, VCO/环路停止);
                                       * 在EnablePLL1中:
                                       *   - 先写PLLPWD=0等PWDSTAT=1: 确保PLL完全关掉;
                                       *   - 配NDIV/PDIV/DIVBY;
                                       *   - 再写PLLPWD=1: 重新上电; */
    Ifx_UReg_32Bit reserved_17:1;     /* [17] 保留 */
    Ifx_UReg_32Bit RESLD:1;           /* [18] Restart DCO Lock Detection - RESLD(w)
                                       * 写1: 重启PLL的锁定检测逻辑(类似SYSPLL的RESLD);
                                       *   - 在PLL上电完成之后, 写RESLD=1, 启动/重启lock detect;
                                       *   - 然后通过PERPLLSTAT.LOCK等待锁定;
                                       */
    Ifx_UReg_32Bit reserved_19:5;     /* [23:19] 保留 */
    Ifx_UReg_32Bit PDIV:3;            /* [26:24] P-Divider Value - PDIV(rw)
                                       * PLL输入分频因子P:
                                       *   fVCO = fIN * NDIV/PDIV
                                       * PDIV典型取值例如:
                                       *   1/2/3/4...(具体编码看PERPLL文档)
                                       * 要求:
                                       *   - 保证PLL输入频率在 [INCLK_MIN, INCLK_MAX] 范围内;
                                       *   - 通常结合晶振频率和目标VCO来反推; */
    Ifx_UReg_32Bit reserved_27:5;     /* [31:27] 保留 */
} Ifx_SCU_PERPLLCON0_Bits;

/* PERPLLCON1: 外设PLL输出端分频(K2→fPLL1, K3→fPLL2) */
typedef struct _Ifx_SCU_PERPLLCON1_Bits
{
    Ifx_UReg_32Bit K2DIV:3;           /* [2:0] K2-Divider Value - K2DIV(rw)
                                       * 输出1(fPLL1)的分频因子:
                                       *   fPLL1 = fVCO/K2(或结合DIVBY有额外因子)
                                       * 你在EnablePLL1里传进来的k2就是写到这里;
                                       * 通常fPLL1用来喂QSPI/高速外设的source1; */
    Ifx_UReg_32Bit reserved_3:5;      /* [7:3] 保留 */
    Ifx_UReg_32Bit K3DIV:3;           /* [10:8] K3-Divider Value - K3DIV(rw)
                                       * 输出2(fPLL2)的分频因子:
                                       *   fPLL2 = fVCO/ (K3 * (DIVBY相关因子))
                                       * 这个输出通常用来喂GETH/MCANH等高带宽外设, 通过CCUCON5那边分频; */
    Ifx_UReg_32Bit reserved_11:21;    /* [31:11] 保留 */
} Ifx_SCU_PERPLLCON1_Bits;

/* PERPLLSTAT: 外设PLL状态灯 */
typedef struct _Ifx_SCU_PERPLLSTAT_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0] 保留 */
    Ifx_UReg_32Bit PWDSTAT:1;         /* [1] Peripheral PLL Power-saving Mode Status - PWDSTAT(rh)
                                       * PLL1当前是否处于Power-down模式:
                                       *   - =1: 处于省电/关机状态;
                                       *   - =0: 处于工作状态(Power-up完成);
                                       * EnablePLL1里就是:
                                       *   - 如果PWDSTAT=0 → 先写PLLPWD=0让它变成1, 等真正关掉;
                                       *   - 再改参数; */
    Ifx_UReg_32Bit LOCK:1;            /* [2] Peripheral PLL Lock Status - LOCK(rh)
                                       * PLL1是否已经锁定到目标频率:
                                       *   - =1: 频率锁定;
                                       *   - =0: 还在锁相过程/未锁;
                                       * 典型用法:
                                       *   - 写完NDIV/PDIV/PLLPWD/RESLD后:
                                       *       while(LOCK==0)等,
                                       *     确认PLL稳定后再挂载到外设时钟树; */
    Ifx_UReg_32Bit reserved_3:1;      /* [3] 保留 */
    Ifx_UReg_32Bit K3RDY:1;           /* [4] K3 Divider Ready Status - K3RDY(rh)
                                       * K3分频器(输出fPLL2)的"新值准备好"状态:
                                       *   - =1: 可以安全写K3DIV或新配置已经被应用;
                                       *   - =0: 硬件仍在更新前一状态, 不要在这时改K3DIV;
                                       * EnablePLL1里也是先while等K3RDY=1再写K3DIV; */
    Ifx_UReg_32Bit K2RDY:1;           /* [5] K2 Divider Ready Status - K2RDY(rh)
                                       * K2分频器(输出fPLL1)的"准备好"状态:
                                       *   - =1: 可以安全写K2DIV或新配置已生效;
                                       *   - =0: 仍在处理中;
                                       * 用法和K3RDY一样, 每次改K2DIV之前先等READY; */
    Ifx_UReg_32Bit reserved_6:1;      /* [6] 保留 */
    Ifx_UReg_32Bit reserved_7:25;     /* [31:7] 保留 */
} Ifx_SCU_PERPLLSTAT_Bits;

/* PMCSR0..5: 每个"电源域/CPU"的低功耗请求 & 当前电源状态
 * 一般PMCSR0~3对应CPU0..3, PMCSR4/5对应额外的逻辑/外设电源域(具体映射看手册);
 * 结构完全一样, 只是作用对象不同;
 */
/* Power Management Control and Status Register for domain 0(典型是CPU0) */
typedef struct _Ifx_SCU_PMCSR0_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /* [1:0] Idle Mode and Sleep Mode Request - REQSLP(rwh)
                                       * "请求进入低功耗"的2bit控制字段;
                                       * 编码(以TC3xx常见风格为例, 具体以手册为准)大致是:
                                       *   00b: 无请求(保持运行模式RUN)
                                       *   01b: 请求Idle模式(CPU停, 外设/总线大多还在)
                                       *   10b: 请求Sleep模式(更深一档, 可能关PLL/大部分域)
                                       *   11b: 保留/未定义
                                       * 属性rwh:
                                       *   - 写: 软件在这个域/CPU下发Idle/Sleep请求;
                                       *   - 读: 可以看到当前请求值;
                                       *   - 硬件在完成模式切换后, 可能会将其清0(具体行为看手册);
                                       * 典型用法(以CPU0为例):
                                       *   //请求CPU0进入Idle:
                                       *   SCU_PMCSR0.B.REQSLP = 0x1;   //Idle请求
                                       *   //请求CPU0进入Sleep:
                                       *   SCU_PMCSR0.B.REQSLP = 0x2;   //Sleep请求
                                       * 实际生效条件:
                                       *   - 通常要配合CPU自己执行WFI/WFE等睡眠指令,
                                       *   - SCU/PMS会根据REQSLP和其它条件决定是否真正把该域带入Idle/Sleep; */
    Ifx_UReg_32Bit reserved_2:6;      /* [7:2] 保留 */
    Ifx_UReg_32Bit PMST:3;            /* [10:8] Power management Status - PMST(rh)
                                       * "当前电源/低功耗状态"的只读状态灯;
                                       * 编码(示意, 具体看PMST表)一般类似:
                                       *   000b:RUN(正常运行)
                                       *   001b:IDLE(已经进入Idle)
                                       *   010b:SLEEP(已经进入深度Sleep)
                                       *   其他值: 可能表示更细分的状态(PREPARE/WAKEUP/STANDBY等)
                                       * 用法:
                                       *   - 在下发REQSLP后轮询PMST看是否已经进入目标状态:
                                       *   //请求CPU0 sleep
                                       *   SCU_PMCSR0.B.REQSLP = 0x2;
                                       *   //等它真正进入SLEEP
                                       *   while(SCU_PMCSR0.B.PMST!= 0x2) {
                                       *       //等待或执行必要的过渡处理
                                       *   }
                                       *   - 唤醒后, 可以读PMST确认当前处于RUN/IDLE等哪种状态,
                                       *     做相应的恢复动作; */
    Ifx_UReg_32Bit reserved_11:21;    /* [31:11] 保留 */
} Ifx_SCU_PMCSR0_Bits;

/* PMCSR1: 一般对应CPU1(结构同PMCSR0) */
typedef struct _Ifx_SCU_PMCSR1_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /* [1:0] 对"域1/CPU1"的Idle/Sleep请求 */
    Ifx_UReg_32Bit reserved_2:6;
    Ifx_UReg_32Bit PMST:3;            /* [10:8] 域1当前的电源状态(RUN/IDLE/SLEEP等) */
    Ifx_UReg_32Bit reserved_11:21;
} Ifx_SCU_PMCSR1_Bits;

/* PMCSR2: 一般对应CPU2 */
typedef struct _Ifx_SCU_PMCSR2_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /* [1:0] 对域2/CPU2的低功耗请求 */
    Ifx_UReg_32Bit reserved_2:6;
    Ifx_UReg_32Bit PMST:3;            /* [10:8] 域2的当前状态 */
    Ifx_UReg_32Bit reserved_11:21;
} Ifx_SCU_PMCSR2_Bits;

/* PMCSR3: 一般对应CPU3 */
typedef struct _Ifx_SCU_PMCSR3_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /* [1:0] 对域3/CPU3的低功耗请求 */
    Ifx_UReg_32Bit reserved_2:6;
    Ifx_UReg_32Bit PMST:3;            /* [10:8] 域3的当前状态 */
    Ifx_UReg_32Bit reserved_11:21;
} Ifx_SCU_PMCSR3_Bits;

/* PMCSR4: 额外电源域(例如Standby Controller/HSM等, 具体看芯片映射说明) */
typedef struct _Ifx_SCU_PMCSR4_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /* [1:0] 对域4的Idle/Sleep请求 */
    Ifx_UReg_32Bit reserved_2:6;
    Ifx_UReg_32Bit PMST:3;            /* [10:8] 域4的当前状态 */
    Ifx_UReg_32Bit reserved_11:21;
} Ifx_SCU_PMCSR4_Bits;

/* PMCSR5: 再一组电源域(比如另一个逻辑岛/通信岛) */
typedef struct _Ifx_SCU_PMCSR5_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /* [1:0] 对域5的Idle/Sleep请求 */
    Ifx_UReg_32Bit reserved_2:6;
    Ifx_UReg_32Bit PMST:3;            /* [10:8] 域5的当前状态 */
    Ifx_UReg_32Bit reserved_11:21;
} Ifx_SCU_PMCSR5_Bits;

/* PMSTAT0: 每个CPU的"电源域开关"和"Lockstep域电源"状态灯 */
typedef struct _Ifx_SCU_PMSTAT0_Bits
{
    Ifx_UReg_32Bit CPU0:1;            /* [0] CPU0 Status - CPU0(rh)
                                       * CPU0电源/时钟域状态:
                                       *   =1:CPU0域处于激活(供电+时钟开启, 可以运行)
                                       *   =0:CPU0域被关(处于某种深低功耗/关闭状态)
                                       * 通常在Sleep/Standby之后用来确认"CPU0这一块电源域是否真的被关/再拉起来"; */
    Ifx_UReg_32Bit CPU1:1;            /* [1] CPU1 Status - CPU1(rh)
                                       *  同理, CPU1域是否启动/供电; */
    Ifx_UReg_32Bit CPU2:1;            /* [2] CPU2 Status - CPU2(rh) */
    Ifx_UReg_32Bit CPU3:1;            /* [3] CPU3 Status - CPU3(rh) */
    Ifx_UReg_32Bit CPU4:1;            /* [4] CPU4 Status - CPU4(rh)
                                       *  如果器件有CPU4/CPU5, 这里就对应它们的电源域;
                                       *  对TC3xx具体看datasheet映射; */
    Ifx_UReg_32Bit CPU5:1;            /* [5] CPU5 Status - CPU5(rh) */
    Ifx_UReg_32Bit reserved_6:10;     /* [15:6] 保留 */
    Ifx_UReg_32Bit CPU0LS:1;          /* [16] CPU0LS Status - CPU0LS(rh)
                                       * CPU0 Lockstep域电源状态:
                                       *   =1:CPU0的lockstep域(比如对核/比较逻辑)处于激活;
                                       *   =0: 该lockstep域未激活或被关;
                                       * 用来和LCLCON0.LS0/LSEN0组合判断:
                                       *   - Lockstep逻辑是否真正"上电且启用"; */
    Ifx_UReg_32Bit CPU1LS:1;          /* [17] CPU1LS Status - CPU1LS(rh)
                                       *  CPU1/CPU3对应的lockstep域是否上电; */
    Ifx_UReg_32Bit CPU2LS:1;          /* [18] CPU2LS Status - CPU2LS(rh) */
    Ifx_UReg_32Bit CPU3LS:1;          /* [19] CPU3LS Status - CPU3LS(rh) */
    Ifx_UReg_32Bit reserved_20:12;    /* [31:20] 保留 */
} Ifx_SCU_PMSTAT0_Bits;

/* PMSWCR1:Standby/Wakeup & CPU Idle/Sleep入口配置 */
typedef struct _Ifx_SCU_PMSWCR1_Bits
{
    Ifx_UReg_32Bit reserved_0:8;      /* [7:0] 保留 */
    Ifx_UReg_32Bit CPUIDLSEL:3;       /* [10:8] CPU selection for Idle mode - CPUIDLSEL(rw)
                                       * 哪个CPU可以通过Idle模式进低功耗:
                                       *   - CPUIDLSEL编码选择特定CPU(比如000=CPU0, 001=CPU1,... 具体看手册);
                                       *   - 只有被选中的CPU, 写PMCSR.REQSLP=Idle(以及执行WFI/WFE)才会触发对应域的Idle流程;
                                       * 用法:
                                       *   - 多核系统中, 你可以选择只有某一个CPU支持"直接Idle/唤醒控制",
                                       *     其他核采用不同策略或不允许Idle; */
    Ifx_UReg_32Bit reserved_11:1;     /* [11] 保留 */
    Ifx_UReg_32Bit IRADIS:1;          /* [12] Idle-Request-Acknowledge Sequence Disable - IRADIS(rw)
                                       * 禁用"Idle请求/确认"的握手序列:
                                       *   =0: 正常使用Idle Request/Ack序列(推荐, 安全稳妥);
                                       *   =1: 关闭该握手(可能缩短进入Idle的路径, 但失去部分状态确认);
                                       * 通常保持0, 除非特别想绕过某些握手流程(需要严格按手册和安全文档说明使用); */
    Ifx_UReg_32Bit reserved_13:11;    /* [23:13] 保留 */
    Ifx_UReg_32Bit CPUSEL:3;          /* [26:24] CPU selection for Sleep and Standby mode - CPUSEL(rw)
                                       * 哪个CPU负责触发Sleep/Standby模式:
                                       *   - 某些芯片要求: 只有一个"主CPU"可以代表系统进入更深的Sleep/Standby;
                                       *   - CPUSEL选择这个"主唤醒/睡眠控制CPU";
                                       * 用法例子:
                                       *   - 在系统中约定:CPU0为电源管理主控 → CPUSEL设成CPU0;
                                       *   - Sleep/Standby请求只能由CPU0流程触发; */
    Ifx_UReg_32Bit STBYEVEN:1;        /* [27] Standby Entry Event configuration enable - STBYEVEN(w)
                                       * 写1: 允许对Standby入口事件进行配置/使能;
                                       * 搭配STBYEV使用:
                                       *   - 先使能STBYEVEN;
                                       *   - 再写STBYEV选择哪个事件能触发Standby进入; */
    Ifx_UReg_32Bit STBYEV:3;          /* [30:28] Standby Entry Event Configuration - STBYEV(rw)
                                       * Standby进入事件的选择:
                                       *   - 比如:
                                       *       000: 由软件请求进入Standby;
                                       *       001: 由某个外部唤醒源/信号驱动;
                                       *       010: 由定时器事件;
                                       *     具体编码取决于芯片文档;
                                       * 搭配STBYEVEN使用, 用于定义"什么事件允许或触发系统进入Standby"; */
    Ifx_UReg_32Bit reserved_31:1;     /* [31] 保留 */
} Ifx_SCU_PMSWCR1_Bits;

/* PMTRCSR0: 电源过渡控制(Load Jump Timer + Voltage Droop Timer的控制) */
typedef struct _Ifx_SCU_PMTRCSR0_Bits
{
    Ifx_UReg_32Bit LJTEN:1;           /* [0] Load Jump Timer Enable - LJTEN(rw)
                                       * 启用"负载跃变计时器"(Load Jump Timer);
                                       * 背景:
                                       *   - 当系统负载突然变化(比如大量外设/核同时开启)时,
                                       *     需要在一定时间窗口内监测/控制电源、电压的响应;
                                       *   - LJT用于在"负载跳变过程"中计时/监控是否超出预期;
                                       * =1: 启用计时器;
                                       * =0: 关闭计时器(相关计时逻辑不工作); */
    Ifx_UReg_32Bit LJTOVEN:1;         /* [1] Load Jump Timer Overflow Enable - LJTOVEN(rw)
                                       * 允许产生"Load Jump Timer溢出"事件:
                                       *   - =1: 当计时超过设定阈值, 会置LJTOV并可进一步触发中断/SMU反应;
                                       *   - =0: 即使溢出也不产生状态/报警; */
    Ifx_UReg_32Bit LJTOVIEN:1;        /* [2] Load Jump Timer Overflow Interrupt Enable - LJTOVIEN(rw)
                                       * 启用LJT溢出的中断:
                                       *   - =1:LJTOV=1时, 会产生中断(结合SRC配置);
                                       *   - =0: 只在状态位里反映, 不触发中断; */
    Ifx_UReg_32Bit LJTSTRT:1;         /* [3] Load Jump Timer Start - LJTSTRT(rwh)
                                       * 写1: 启动LJT计时(开始计数);
                                       * 读: 可看当前启动状态(硬件可能会自动清零); */
    Ifx_UReg_32Bit LJTSTP:1;          /* [4] Load Jump Timer Stop - LJTSTP(rw)
                                       * 写1: 停止LJT计数; */
    Ifx_UReg_32Bit LJTCLR:1;          /* [5] Load Jump Timer Clear - LJTCLR(w)
                                       * 写1: 清除LJT计数器值和相关状态(比如溢出标志); */
    Ifx_UReg_32Bit reserved_6:6;      /* [11:6] 保留 */
    Ifx_UReg_32Bit SDSTEP:4;          /* [15:12] Droop Voltage Step(vdroop_step_i) - SDSTEP(rw)
                                       * 电压下降(Droop)步进设置, 控制"在负载跃变时电压调节的步长";
                                       * - 值越大, 电压步进越大/恢复更快, 但可能导致震荡;
                                       * - 值越小, 变化更平滑, 但响应更慢;
                                       * 具体意义和单位取决于电源控制器设计(EVRC/PMS); */
    Ifx_UReg_32Bit VDTEN:1;           /* [16] Voltage Droop Timer Enable - VDTEN(rw)
                                       * 启用"Voltage Droop Timer"(电压下垂计时器):
                                       *   =1: 开启对电压下垂过程的计时;
                                       *   =0: 关闭该计时器; */
    Ifx_UReg_32Bit VDTOVEN:1;         /* [17] Voltage Droop Timer Overflow Enable - VDTOVEN(rw)
                                       * 启用VDTimer溢出事件的生成(类似LJTOVEN); */
    Ifx_UReg_32Bit VDTOVIEN:1;        /* [18] Voltage Droop Timer Overflow Interrupt Enable - VDTOVIEN(rw)
                                       * 启用"电压下垂计时器溢出"的中断; */
    Ifx_UReg_32Bit VDTSTRT:1;         /* [19] Voltage Droop Timer Start - VDTSTRT(rwh)
                                       * 写1: 启动电压下垂计时器(开始计数),
                                       * 读: 可看当前是否处于运行状态; */
    Ifx_UReg_32Bit VDTSTP:1;          /* [20] Voltage Droop Timer Stop - VDTSTP(rw)
                                       * 写1: 停止电压下垂计时器; */
    Ifx_UReg_32Bit VDTCLR:1;          /* [21] Voltage Droop Timer Clear - VDTCLR(w)
                                       * 写1: 清除电压下垂计时器的计数和溢出状态; */
    Ifx_UReg_32Bit reserved_22:7;     /* [28:22] 保留 */
    Ifx_UReg_32Bit LPSLPEN:1;         /* [29] EVRC Low Power Mode activation on a Sleep Request - LPSLPEN(rw)
                                       * 当有Sleep请求时, 是否让 **EVRC(内部电压调节模块)** 进入低功耗模式;
                                       * =1: 当系统进入Sleep时, EVRC自动转入低功耗;
                                       * =0:Sleep时保持EVRC在正常模式(更多电源裕度, 但功耗高); */
    Ifx_UReg_32Bit reserved_30:2;     /* [31:30] 保留 */
} Ifx_SCU_PMTRCSR0_Bits;

/* PMTRCSR1: 两个计时器的比较值(阈值) */
typedef struct _Ifx_SCU_PMTRCSR1_Bits
{
    Ifx_UReg_32Bit LJTCV:16;          /* [15:0] Load Jump Timer Compare Setpoint Value - LJTCV(rw)
                                       * LJT的"时间阈值":
                                       *   - 计数到LJTCV时, 如果还没完成预期过程, 就认为超时/异常,
                                       *     由LJTOV/LJTOVEN/LJTOVIEN决定具体反应; */
    Ifx_UReg_32Bit VDTCV:10;          /* [25:16] Voltage Droop Timer Compare Setpoint Value - VDTCV(rw)
                                       * VDT的"时间阈值":
                                       *   - 计数到VDTCV时, 电压下垂过程还未结束, 就判定为超时; */
    Ifx_UReg_32Bit reserved_26:6;     /* [31:26] 保留 */
} Ifx_SCU_PMTRCSR1_Bits;

/* PMTRCSR2:Load Jump Timer状态寄存器 */
typedef struct _Ifx_SCU_PMTRCSR2_Bits
{
    Ifx_UReg_32Bit LDJMPREQ:2;        /* [1:0] Load Jump Request - LDJMPREQ(rwh)
                                       * "负载跳变请求"字段:
                                       *   - 软件/硬件可以通过设置它来标记当前存在某种负载跃变情形,
                                       *   - SCU/PMS利用这个信息配合LJT做电源/电压调节;
                                       * rwh: 既可写(发起/修改请求类型), 也可读(查看当前请求状态),
                                       * 硬件可能在处理完后自动清除或更新; */
    Ifx_UReg_32Bit reserved_2:2;      /* [3:2] 保留 */
    Ifx_UReg_32Bit LJTRUN:2;          /* [5:4] Load Jump Timer Run Status - LJTRUN(rh)
                                       * LJT当前运行状态:
                                       *   - 例如00=停止, 01=运行, 10=暂停等(具体编码看文档);
                                       *   - 用于确认LJT是否已经被启动/是否还在计时; */
    Ifx_UReg_32Bit reserved_6:2;      /* [7:6] 保留 */
    Ifx_UReg_32Bit LJTOV:1;           /* [8] Load Jump Timer Overflow Status - LJTOV(rh)
                                       * LJT是否"超时/溢出":
                                       *   =1: 计时超过设定的LJTCV, 视为"负载跳变响应超时";
                                       *   =0: 未溢出/正常; */
    Ifx_UReg_32Bit reserved_9:3;      /* [11:9] 保留 */
    Ifx_UReg_32Bit LJTOVCLR:1;        /* [12] Load Jump Timer Overflow Status Clear - LJTOVCLR(w)
                                       * 写1: 清LJTOV状态标志; */
    Ifx_UReg_32Bit reserved_13:3;     /* [15:13] 保留 */
    Ifx_UReg_32Bit LJTCNT:16;         /* [31:16] Load Jump Timer Value - LJTCNT(rh)
                                       * LJT当前计数值(对调试/监控很有用):
                                       *   - 可以用于观察"从启动LJT到现在总共过了多少个计数单位",
                                       *   - 在系统分析/调参与故障分析时, 用来确认实际时间行为; */
} Ifx_SCU_PMTRCSR2_Bits;

/* PMTRCSR3:Voltage Droop Timer状态寄存器 */
typedef struct _Ifx_SCU_PMTRCSR3_Bits
{
    Ifx_UReg_32Bit VDROOPREQ:2;       /* [1:0] Voltage Droop Request - VDROOPREQ(rwh)
                                       * "电压下垂请求"字段:
                                       *   - 用于标记/发起某种电压调节过程(例如负载变化时暂时降低/调整电压),
                                       *   - SCU/PMS根据请求类型和VDTCV等参数控制EVRC; */
    Ifx_UReg_32Bit reserved_2:2;      /* [3:2] 保留 */
    Ifx_UReg_32Bit VDTRUN:2;          /* [5:4] Voltage Droop Timer Run Status - VDTRUN(rh)
                                       * VDT当前运行状态(正在计时/已停止等); */
    Ifx_UReg_32Bit reserved_6:2;      /* [7:6] 保留 */
    Ifx_UReg_32Bit VDTOV:1;           /* [8] Voltage Droop Timer Overflow Status - VDTOV(rh)
                                       * 电压下垂计时器是否"超时/溢出":
                                       *   =1: 电压调整过程超出设定时间;
                                       *   =0: 在规定时间内完成; */
    Ifx_UReg_32Bit reserved_9:3;      /* [11:9] 保留 */
    Ifx_UReg_32Bit VDTOVCLR:1;        /* [12] Voltage Droop Timer Overflow Status Clear - VDTOVCLR(w)
                                       * 写1: 清除VDTOV溢出状态; */
    Ifx_UReg_32Bit reserved_13:3;     /* [15:13] 保留 */
    Ifx_UReg_32Bit VDTCNT:10;         /* [25:16] Voltage Droop Timer Value - VDTCNT(rh)
                                       * VDT当前计数值:
                                       *   - 记录从VDTSTRT起到当前的"计数进度",
                                       *   - 可用于调参与诊断; */
    Ifx_UReg_32Bit reserved_26:6;     /* [31:26] 保留 */
} Ifx_SCU_PMTRCSR3_Bits;

/* RSTCON: 各种"复位请求源" → 选择它们触发哪种复位的配置表 */
typedef struct _Ifx_SCU_RSTCON_Bits
{
    Ifx_UReg_32Bit ESR0:2;            /* [1:0] ESR0 Reset Request Trigger Reset Configuration - ESR0(rw)
                                       * 配置"ESR0这路复位请求"触发什么范围的复位;
                                       * 2bit编码通常类似(以AURIX风格举例, 具体看手册):
                                       *   00b: 不触发任何复位(仅作为事件/唤醒信号)
                                       *   01b: 只触发Application Reset(应用层复位)
                                       *   10b: 触发System Reset(系统复位)
                                       *   11b: 触发Cold Reset/POR级别复位(如果支持)
                                       * 人话:
                                       *   - 外部PMIC/按钮拉ESR0时, 你可以选择:
                                       *       - 只重启应用;
                                       *       - 或整个芯片软复位;
                                       *       - 或硬性全局复位; */
    Ifx_UReg_32Bit ESR1:2;            /* [3:2] ESR1 Reset Request Trigger Reset Configuration - ESR1(rw)
                                       * 同理, 为第二路ESR1配置"按下时复位多大"; */
    Ifx_UReg_32Bit reserved_4:2;      /* [5:4] 保留 */
    Ifx_UReg_32Bit SMU:2;             /* [7:6] SMU Reset Request Trigger Reset Configuration - SMU(rw)
                                       * 安全监控单元(SMU)发出Reset Request时, 触发哪种复位?
                                       *   - 有的错误只需要应用复位;
                                       *   - 更严重的安全错误可能需要系统复位/冷复位;
                                       * 这里通过2bit编码设定SMU的"复位力度"; */
    Ifx_UReg_32Bit SW:2;              /* [9:8] SW Reset Request Trigger Reset Configuration - SW(rw)
                                       * 软件复位(软件写某个寄存器触发reset)对应的配置:
                                       *   - 框定"软件reset是应用reset还是系统reset"; */
    Ifx_UReg_32Bit STM0:2;            /* [11:10] STM0 Reset Request Trigger Reset Configuration - STM0(rw)
                                       * STM0(系统定时器)比较匹配触发的"复位请求"要重置多大范围;
                                       * 例如:
                                       *   - 用STM0做"系统看门狗"时, 溢出/未喂狗触发reset,
                                       *     你可以设定它只reset CPU/应用, 还是整个系统; */
    Ifx_UReg_32Bit STM1:2;            /* [13:12] 同上, 对STM1 */
    Ifx_UReg_32Bit STM2:2;            /* [15:14] 同上, 对STM2 */
    Ifx_UReg_32Bit STM3:2;            /* [17:16] 同上, 对STM3 */
    Ifx_UReg_32Bit reserved_18:2;     /* [19:18] 保留 */
    Ifx_UReg_32Bit reserved_20:2;     /* [21:20] 保留 */
    Ifx_UReg_32Bit reserved_22:10;    /* [31:22] 保留 */
} Ifx_SCU_RSTCON_Bits;

/* RSTCON2: 附加复位控制 + 用户信息区 */
typedef struct _Ifx_SCU_RSTCON2_Bits
{
    Ifx_UReg_32Bit FRTO:1;            /* [0] Force Reset Timeout - FRTO(rw)
                                       * 是否启用"强制复位超时"控制:
                                       *   =1: 对某些reset序列启用timeout保护(时间过长则强制reset);
                                       *   =0: 不启用(reset可一直等);
                                       * 用于防止reset过程卡在某个步骤, 系统永远不起; */
    Ifx_UReg_32Bit CLRC:1;            /* [1] Clear Cold Reset Status - CLRC(w)
                                       * 写1: 清除"Cold Reset状态标志"(通常在某个状态寄存器中);
                                       * 也就是: 清掉"我刚刚经历过一次冷复位"的记录; */
    Ifx_UReg_32Bit reserved_2:1;      /* [2] 保留 */
    Ifx_UReg_32Bit reserved_3:1;      /* [3] 保留 */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit reserved_5:1;      /* [5] 保留 */
    Ifx_UReg_32Bit reserved_6:1;      /* [6] 保留 */
    Ifx_UReg_32Bit CSSX:6;            /* [12:7] CPU x Shutdown State Reached - CSSx(rh)
                                       * 每bit表示某个CPU是否"已达到Shutdown状态";
                                       * 这个状态通常在进Standby/Shutdown流程时, 用来确认各核已经安全停机; */
    Ifx_UReg_32Bit reserved_13:1;     /* [13] 保留 */
    Ifx_UReg_32Bit reserved_14:1;     /* [14] 保留 */
    Ifx_UReg_32Bit reserved_15:1;     /* [15] 保留 */
    Ifx_UReg_32Bit USRINFO:16;        /* [31:16] User Information - USRINFO(rw)
                                       * 用户可自定义的"复位信息字段";
                                       * 常见用途:
                                       *   - 在触发软件复位/SMU复位前写入一个原因码:
                                       *       SCU_RSTCON2.B.USRINFO = 0x1234;  //比如"看门狗触发复位"
                                       *   - 复位后的启动代码读取这个字段, 判断上次复位原因/来自哪个路径;
                                       * 这对于复杂系统的"复位诊断"和日志非常有用; */
} Ifx_SCU_RSTCON2_Bits;

/* RSTCON3: 当前保留, 无可用字段 */
typedef struct _Ifx_SCU_RSTCON3_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /* [31:0] internal Reserved */
} Ifx_SCU_RSTCON3_Bits;

/* RSTSTAT: 复位状态寄存器——到底是谁把我给Reset的? */
typedef struct _Ifx_SCU_RSTSTAT_Bits
{
    Ifx_UReg_32Bit ESR0:1;            /* [0] Reset Request Trigger Reset Status for ESR0 - ESR0(rh)
                                       * =1: 最近一次复位是(之一)由ESR0的Reset Request引发的;
                                       * 常用于判断"是外部PMIC/按钮通过ESR0复位了芯片"; */
    Ifx_UReg_32Bit ESR1:1;            /* [1] 同理, ESR1是否参与这次复位 */
    Ifx_UReg_32Bit reserved_2:1;      /* [2] 保留 */
    Ifx_UReg_32Bit SMU:1;             /* [3] Reset Status for SMU - SMU(rh)
                                       * =1: 复位是由SMU发出的Reset Request(安全相关故障)引发; */
    Ifx_UReg_32Bit SW:1;              /* [4] Reset Status for SW - SW(rh)
                                       * =1: 软件触发的reset(比如写了某个SWRST寄存器); */
    Ifx_UReg_32Bit STM0:1;            /* [5] Reset Status for STM0 Compare Match - STM0(rh)
                                       * =1:STM0看门狗式的比较匹配触发reset; */
    Ifx_UReg_32Bit STM1:1;            /* [6] 同上, 对STM1 */
    Ifx_UReg_32Bit STM2:1;            /* [7] 同上, 对STM2 */
    Ifx_UReg_32Bit STM3:1;            /* [8] 同上, 对STM3 */
    Ifx_UReg_32Bit reserved_9:1;      /* [9] 保留 */
    Ifx_UReg_32Bit reserved_10:1;     /* [10] 保留 */
    Ifx_UReg_32Bit reserved_11:5;     /* [15:11] 保留 */
    Ifx_UReg_32Bit PORST:1;           /* [16] Reset Status for PORST - PORST(rh)
                                       * =1: 这次复位是电源上电(Power-On Reset)导致的; */
    Ifx_UReg_32Bit reserved_17:1;     /* [17] 保留 */
    Ifx_UReg_32Bit CB0:1;             /* [18] Cerberus System Reset - CB0(rh) */
    Ifx_UReg_32Bit CB1:1;             /* [19] Cerberus Debug Reset - CB1(rh) */
    Ifx_UReg_32Bit CB3:1;             /* [20] Cerberus Application Reset - CB3(rh)
                                       * 这几个CBx位对应HSM/Cerberus安全模块发出的各种reset类型; */
    Ifx_UReg_32Bit reserved_21:1;     /* [21] 保留 */
    Ifx_UReg_32Bit reserved_22:1;     /* [22] 保留 */
    Ifx_UReg_32Bit EVRC:1;            /* [23] Reset Status for EVRC - EVRC(rh)
                                       *  内部电压调节模块EVRC相关reset; */
    Ifx_UReg_32Bit EVR33:1;           /* [24] Reset Status for EVR33 - EVR33(rh)
                                       *  3.3V EVR问题导致的reset; */
    Ifx_UReg_32Bit SWD:1;             /* [25] Reset Status for Supply Watchdog(SWD) - SWD(rh)
                                       * 电源看门狗(比如检查电压轨是否在安全范围)触发reset; */
    Ifx_UReg_32Bit HSMS:1;            /* [26] HSM System Reset - HSMS(rh) */
    Ifx_UReg_32Bit HSMA:1;            /* [27] HSM Application Reset - HSMA(rh) */
    Ifx_UReg_32Bit STBYR:1;           /* [28] Standby Regulator Watchdog Reset - STBYR(rh)
                                       * Standby稳压器失常或看门狗触发的reset; */
    Ifx_UReg_32Bit LBPORST:1;         /* [29] LBIST termination due to PORST(rh)
                                       * =1:LBIST被PORST中断(非正常结束); */
    Ifx_UReg_32Bit LBTERM:1;          /* [30] LBIST was properly terminated(rh)
                                       * =1:LBIST正常按流程结束(不是被reset打断); */
    Ifx_UReg_32Bit reserved_31:1;     /* [31] 保留 */
} Ifx_SCU_RSTSTAT_Bits;

/* SEICON0:Safety ENDINIT的密码+超时时间配置 */
typedef struct _Ifx_SCU_SEICON0_Bits
{
    Ifx_Strict_32Bit reserved_0:1;    /* [0] 保留 */
    Ifx_Strict_32Bit ENDINIT:1;       /* [1] End-of-Initialization Control Bit - ENDINIT(rwh)
                                       * 安全ENDINIT控制位:
                                       *   - =1:Safety ENDINIT锁开启(默认状态, 受保护寄存器不可写);
                                       *   - =0:Safety ENDINIT解锁窗口开启(在密码/序列正确的情况下),
                                       *         可短时间修改一小撮Safety关键寄存器(SCU/PLL/CCU/EVC等);
                                       * 典型调用封装:
                                       *   - unlock_safety_wdtcon()内部就会按规则写SEICON0/1,
                                       *     暂时把ENDINIT拉到0;
                                       *   - 修改完关键寄存器后, 再lock_safety_wdtcon()把ENDINIT置回1; */
    Ifx_Strict_32Bit EPW:14;          /* [15:2] User-Definable Safety ENDINIT Password Field - EPW(rwh)
                                       * Safety ENDINIT解锁需要的"用户密码字段";
                                       * - 在使用Safety ENDINIT之前, 你可以在EPW里配置一个自己的密码;
                                       * - 解锁/上锁操作时, 硬件会检查写入序列+EPW是否匹配;
                                       * - 这样可以提高"防误操作/防攻击"能力;
                                       * 一般高层函数(unlock_safety_wdtcon)已经封装了正确的写法,
                                       * 正常应用不直接操作EPW, FuSa项目中会统一定义一个密码; */
    Ifx_Strict_32Bit REL:16;          /* [31:16] Reload Value for the Safety ENDINIT Timeout Counter - REL(r)
                                       * Safety ENDINIT超时时间计数器的重装值(只读);
                                       * - ENDINIT解锁窗口不会无限长, REL定义了最大允许时间;
                                       * - 超时后, 硬件会强制恢复ENDINIT状态或触发错误;
                                       * 通常这些值由芯片预置, 不建议也不能软件改; */
} Ifx_SCU_SEICON0_Bits;

/* SEICON1:Safety ENDINIT附加控制(输入频率/禁用请求等) */
typedef struct _Ifx_SCU_SEICON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0] 保留 */
    Ifx_UReg_32Bit reserved_1:1;      /* [1] 保留 */
    Ifx_UReg_32Bit IR0:1;             /* [2] Input Frequency Request Control - IR1, IR0(rw)
                                       * 和IR1一起, 选择Safety ENDINIT超时计数器使用的输入频率:
                                       *   - 00: 某个默认时钟
                                       *   - 01: 更快/更慢的时钟
                                       *   - 10/11: 其他频点
                                       * 具体组合要看SEICON部分的文档;
                                       * 目的:
                                       *   - 不同频率 → 不同解锁窗口时间(=REL/f_input);
                                       *   - 你可以通过IR1/IR0调整ENDINIT解锁窗口的大致时长; */
    Ifx_UReg_32Bit DR:1;              /* [3] Disable Request Control Bit - DR(rw)
                                       * 控制Safety ENDINIT功能的"禁用请求":
                                       *   - 在某些测试模式或特殊授权下, 可以临时将Safety ENDINIT机制整体disable,
                                       *     允许访问受保护寄存器而不走正常解锁流程;
                                       * 高危操作:
                                       *   - 一般只有在工厂测试/特定安全模式下使用,
                                       *   - 正常应用不应该随意设置DR, 避免完全失去ENDINIT保护; */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit IR1:1;             /* [5] Input Frequency Request Control - IR1, IR0(rw)
                                       * 与IR0组合, 控制ENDINIT timeout计数器的输入频率;
                                       * 比如:
                                       *   IR1:IR0 = 00:f0
                                       *             01:f1
                                       *             10:f2
                                       *             11:f3
                                       * 不同频率直接影响REL对应的实际时间; */
    Ifx_UReg_32Bit reserved_6:26;     /* [31:6] 保留 */
} Ifx_SCU_SEICON1_Bits;

/* SEISR:Safety ENDINIT超时/状态寄存器 */
typedef struct _Ifx_SCU_SEISR_Bits
{
    Ifx_UReg_32Bit AE:1;              /* [0] SEICON0 Access Error Status Flag - AE(rh)
                                       * =1: 上一次对SEICON0/1的访问序列不合法(密码/顺序错误等),
                                       *      硬件判定为"访问错误";
                                       * 用于诊断"谁在乱动Safety ENDINIT相关寄存器"; */
    Ifx_UReg_32Bit OE:1;              /* [1] SEI Timeout Overflow Error Status Flag - OE(rh)
                                       * =1:Safety ENDINIT解锁窗口"超时溢出"——
                                       *     即在规定时间内没有重新恢复ENDINIT, 计时器溢出;
                                       * 这是一个很严重的状态, 一般会触发SMU/安全反应; */
    Ifx_UReg_32Bit IS0:1;             /* [2] SEI Timeout Input Clock Status - IS0, IS1(rh)
                                       * IS0/IS1组合反映"当前用于ENDINIT超时计数的输入时钟源/频率"状态,
                                       * 与SEICON1.IR1/IR0相关;
                                       * 用于确认"计时器是用哪个频率在跑"的状态灯; */
    Ifx_UReg_32Bit DS:1;              /* [3] SEI Enable/Disable Status Flag - DS(rh)
                                       * ENDINIT机制整体启用/禁用的状态(受SEICON1.DR等影响):
                                       *   =1:ENDINIT保护功能当前Enabled;
                                       *   =0:ENDINIT保护功能被Disable(危险状态, 仅限测试/特殊模式); */
    Ifx_UReg_32Bit TO:1;              /* [4] SEI Time-Out Mode Flag - TO(rh)
                                       * 标记当前是否处于"时间限制模式"(Time-Out Mode)——
                                       * 例如在超时之后进入某种降级/自恢复模式; */
    Ifx_UReg_32Bit IS1:1;             /* [5] SEI Timeout Input Clock Status - IS1(rh)
                                       * 和IS0一起解读输入频率; */
    Ifx_UReg_32Bit reserved_6:10;     /* [15:6] 保留 */
    Ifx_UReg_32Bit TIM:16;            /* [31:16] Timer Value - TIM(rh)
                                       * 当前Safety ENDINIT超时计数器的数值;
                                       * - 在解锁窗口内递减/递增, 用于判断是否超时;
                                       * - 对调试ENDINIT行为(比如确认窗口时长)有一定参考价值; */
} Ifx_SCU_SEISR_Bits;

/* STCON: 启动配置寄存器(主要管Flash配置扇区访问和启动保护) */
typedef struct _Ifx_SCU_STCON_Bits
{
    Ifx_UReg_32Bit reserved_0:13;     /* [12:0] 保留 */
    Ifx_UReg_32Bit SFCBAE:1;          /* [13] Set Flash Config. Sector Access Enable - SFCBAE(w)
                                       * 写1:**打开"Flash Config Sector(配置扇区)访问使能"**;
                                       * - 这类扇区通常存放启动配置、安全配置等敏感信息;
                                       * - 默认被锁, 写SFCBAE=1允许访问(读/写), 需要非常小心; */
    Ifx_UReg_32Bit CFCBAE:1;          /* [14] Clear Flash Config. Sector Access Enable - CFCBAE(w)
                                       * 写1: 关闭配置扇区访问使能, 即"重新锁回去"; */
    Ifx_UReg_32Bit STP:1;             /* [15] Start-up Protection Setting - STP(rwh)
                                       * 启动保护设置标志:
                                       *   - =1: 某些启动配置/安全选项已锁定(不可再随意修改);
                                       *   - =0: 允许修改(在特定阶段, 比如工厂或预配置阶段);
                                       * rwh: 写可改, 读可看当前状态, 硬件也可能根据某些条件更新; */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_STCON_Bits;

/* STMEMx:Start-up Memory寄存器组(6个32bit) */
typedef struct _Ifx_SCU_STMEM1_Bits
{
    Ifx_UReg_32Bit MEM:32;            /* [31:0] Memory - MEM(rw)
                                       * 启动配置/安全参数等的存储区域(寄存器版),
                                       * 常用于保存Boot ROM/Bootloader使用的起始配置值; */
} Ifx_SCU_STMEM1_Bits;

typedef struct _Ifx_SCU_STMEM2_Bits {
  Ifx_UReg_32Bit MEM:32;
} Ifx_SCU_STMEM2_Bits;

typedef struct _Ifx_SCU_STMEM3_Bits {
  Ifx_UReg_32Bit MEM:32;
} Ifx_SCU_STMEM3_Bits;

typedef struct _Ifx_SCU_STMEM4_Bits {
  Ifx_UReg_32Bit MEM:32;
} Ifx_SCU_STMEM4_Bits;

typedef struct _Ifx_SCU_STMEM5_Bits {
  Ifx_UReg_32Bit MEM:32;
} Ifx_SCU_STMEM5_Bits;

typedef struct _Ifx_SCU_STMEM6_Bits {
  Ifx_UReg_32Bit MEM:32;
} Ifx_SCU_STMEM6_Bits;

/* 6个STMEM寄存器通常组合用, 逻辑上是一块小的"启动参数RAM",
 * 具体每个位的含义依芯片/项目的启动流程定义而定; */
/* STSTAT: 启动状态寄存器, 记录"上电时硬件配置/测试状态" */
typedef struct _Ifx_SCU_STSTAT_Bits
{
    Ifx_UReg_32Bit HWCFG:8;           /* [7:0] Hardware Configuration Setting - HWCFG(rh)
                                       * 上电时读取的"硬件配置开关"的结果:
                                       *   - 比如HWCFG[3:0] 对应HWCFG引脚或熔丝,
                                       *     决定启动模式、引导源(Flash/Bootloader/BCU测试)等; */
    Ifx_UReg_32Bit FTM:7;             /* [14:8] Firmware Test Setting - FTM(rh)
                                       * 上电固件测试配置(Firmware Test Mode):
                                       *   - 比如决定Boot ROM是否进入某个自检模式;
                                       *   - or是否启用某些制造测试路径; */
    Ifx_UReg_32Bit MODE:1;            /* [15] MODE - MODE(rh)
                                       * 启动模式标志:
                                       *   - 通常区分"正常启动/测试启动/安全模式启动"等;
                                       *   - 具体含义看芯片的启动模式章节; */
    Ifx_UReg_32Bit FCBAE:1;           /* [16] Flash Config. Sector Access Enable - FCBAE(rh)
                                       * 只读版本的"配置扇区访问是否开启"状态:
                                       *   - =1: 当前允许访问Flash Config Sector;
                                       *   - =0: 处于保护/锁定状态; */
    Ifx_UReg_32Bit LUDIS:1;           /* [17] Latch Update Disable - LUDIS(rh)
                                       * 当前是否启用了"锁存更新禁止":
                                       *   - 一些输出/引脚/状态latch在LUDIS=1时会被冻结,
                                       *   - 用于特定test模式或电气测量, 避免输出变化; */
    Ifx_UReg_32Bit reserved_18:1;     /* [18] 保留 */
    Ifx_UReg_32Bit TRSTL:1;           /* [19] TRSTL Status - TRSTL(rh)
                                       * JTAG TRSTn引脚状态(Test Reset):
                                       *   - =0/1表示当前TRSTn电平状态,
                                       *   - 影响调试接口是否处于复位状态; */
    Ifx_UReg_32Bit SPDEN:1;           /* [20] Single Pin DAP Mode Enable - SPDEN(rh)
                                       * 是否启用了Single Pin DAP调试模式:
                                       *   - =1: 当前处于Single Pin DAP模式;
                                       *   - =0: 正常DAP/JTAG模式; */
    Ifx_UReg_32Bit reserved_21:1;     /* [21] 保留 */
    Ifx_UReg_32Bit reserved_22:1;     /* [22] 保留 */
    Ifx_UReg_32Bit reserved_23:1;     /* [23] 保留 */
    Ifx_UReg_32Bit RAMINT:1;          /* [24] RAM Content Security Integrity - RAMINT(rh)
                                       * RAM内容安全完整性标志:
                                       *   - 启动时对RAM做的某种自检(ECC/Pattern)结果,
                                       *   - =1可能代表"RAM自检成功",
                                       *   - =0代表"RAM自检未通过/未执行";
                                       * 具体含义要看RAM自检章节, 但用于启动阶段安全判断; */
    Ifx_UReg_32Bit reserved_25:3;     /* [27:25] 保留 */
    Ifx_UReg_32Bit reserved_28:4;     /* [31:28] 保留 */
} Ifx_SCU_STSTAT_Bits;

/* SWAPCTRL: 地址映射控制寄存器(Boot/Overlay/bank swap相关) */
typedef struct _Ifx_SCU_SWAPCTRL_Bits
{
    Ifx_UReg_32Bit ADDRCFG:2;         /* [1:0] Address Configuration(rw)
                                       * 选择系统地址空间的配置方式:
                                       *   - 例如在某些芯片上可以:
                                       *       - 交换PFlash Bank0/Bank1的位置,
                                       *       - 或改变Boot区在0x8000_0000/0xA000_0000等映射;
                                       * 具体编码要看"Address Map/SwapBoot"章节, 一般用于:
                                       *   - 切换两个固件镜像的启动顺序(主/备份固件);
                                       *   - 在OTA更新后, 把新固件bank作为默认boot bank; */
    Ifx_UReg_32Bit SPARE:14;          /* [15:2] Spare address configuration registers(rw)
                                       * 预留给额外地址映射相关的配置用(不同衍生型可能实现一部分); */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_SWAPCTRL_Bits;

/* SWRSTCON:Software Reset Request配置寄存器 */
typedef struct _Ifx_SCU_SWRSTCON_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0] 保留 */
    Ifx_UReg_32Bit SWRSTREQ:1;        /* [1] Software Reset Request - SWRSTREQ(w)
                                       * 写1: 请求一次软件复位(具体复位类型由RSTCON.SW配置决定);
                                       * 常用流程:
                                       *   - 写USRINFO填入复位原因;
                                       *   - 写RSTCON.SW选择"应用/系统/冷复位"级别;
                                       *   - 写SWRSTREQ=1触发复位;
                                       *   - 之后芯片通过RSTSTAT的SW=1你可知道是软件复位; */
    Ifx_UReg_32Bit reserved_2:6;      /* [7:2] 保留 */
    Ifx_UReg_32Bit reserved_8:8;      /* [15:8] 保留 */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_SWRSTCON_Bits;

/* SYSCON: 系统控制寄存器(一些杂项控制位) */
typedef struct _Ifx_SCU_SYSCON_Bits
{
    Ifx_UReg_32Bit CCTRIG0:1;         /* [0] Capture Compare Trigger 0 - CCTRIG0(rw)
                                       * 全局Capture/Compare触发控制, 比如:
                                       *   - 写1: 触发某个系统级CC事件(具体对象看芯片文档),
                                       *   - 可用于测试定时/比较系统的响应; */
    Ifx_UReg_32Bit reserved_1:1;      /* [1] 保留 */
    Ifx_UReg_32Bit RAMINTM:2;         /* [3:2] RAM Integrity Modify - RAMINTM(w)
                                       * 修改RAM自检/完整性行为的控制位(写1触发特定操作):
                                       *   - 比如强制重新执行RAM自检、
                                       *   - 修改某些自检模式(全测试/快速测试),
                                       *   - 再配合STSTAT.RAMINT看结果;
                                       * 具体编码需参考RAM/BIST相关章节; */
    Ifx_UReg_32Bit SETLUDIS:1;        /* [4] Set Latch Update Disable - SETLUDIS(w)
                                       * 写1: 设置Latch Update Disable(禁用某些锁存更新);
                                       *   - 对应STSTAT.LUDIS状态位;
                                       *   - 用于某些测试/测量场景, 阻止输出/状态变化; */
    Ifx_UReg_32Bit reserved_5:1;      /* [5] 保留 */
    Ifx_UReg_32Bit reserved_6:1;      /* [6] 保留 */
    Ifx_UReg_32Bit reserved_7:1;      /* [7] 保留 */
    Ifx_UReg_32Bit DDC:1;             /* [8] Disable DXCPL - DDC(rw)
                                       * 关闭某些"数据交换/耦合逻辑"(DXCPL),
                                       * 具体是哪个逻辑看SoC文档;(在某些芯片上是Data Trace/采样相关电路)
                                       * 一般默认0(使能), 特殊诊断/EMC问题调查时可能设1; */
    Ifx_UReg_32Bit reserved_9:7;      /* [15:9] 保留 */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_SYSCON_Bits;

/* SYSPLLCON0: 系统PLL0核心配置寄存器 */
typedef struct _Ifx_SCU_SYSPLLCON0_Bits
{
    Ifx_UReg_32Bit reserved_0:2;      /* [1:0] 保留 */
    Ifx_UReg_32Bit MODEN:1;           /* [2] Modulation Enable - MODEN(rw)
                                       * 频率调制(spread-spectrum)启用:
                                       *   =1: 启用PLL输出频率的微小调制, 降低EMI(常用在高频时钟体系里);
                                       *   =0: 禁用调制, PLL输出固定频率;
                                       * 对EMI敏感的项目通常会打开, 并配合SYSPLLCON2.MODCFG;  
                                       * 对高精度时序要求很苛刻的情况(某些测量应用),
                                       * 可能会关闭, 以获得更稳定频率; */
    Ifx_UReg_32Bit reserved_3:6;      /* [8:3] 保留 */
    Ifx_UReg_32Bit NDIV:7;            /* [15:9] N-Divider Value - NDIV(rw)
                                       * VCO倍频因子N:
                                       *   fVCO = fIN * NDIV/PDIV
                                       * 你在EnablePLL0(pdiv, ndiv, k2)里传入的ndiv就是填这里; */
    Ifx_UReg_32Bit PLLPWD:1;          /* [16] System PLL Power Saving Mode - PLLPWD(rw)
                                       * 系统PLL的关机/省电控制:
                                       *   =0:Power-down, PLL停止(VCO关, 环路不工作);
                                       *   =1:Power-up, PLL工作;
                                       * EnablePLL0里先把它拉到0+等PWDSTAT=1, 关机;
                                       * 配PDIV/NDIV, 再写1上电; */
    Ifx_UReg_32Bit reserved_17:1;     /* [17] 保留 */
    Ifx_UReg_32Bit RESLD:1;           /* [18] Restart DCO Lock Detection - RESLD(w)
                                       * 写1: 重新启动锁定检测(lock detect)逻辑,
                                       * 通常在PLL上电后立刻写, 随后等SYSPLLSTAT.LOCK=1; */
    Ifx_UReg_32Bit reserved_19:5;     /* [23:19] 保留 */
    Ifx_UReg_32Bit PDIV:3;            /* [26:24] P-Divider Value - PDIV(rw)
                                       * 输入分频因子P:
                                       *   fVCO = fIN * NDIV/PDIV
                                       * 与NDIV一起确定VCO频率, 要求:
                                       *   - fIN在 [INCLK_MIN, INCLK_MAX],
                                       *   - fVCO在 [VCO_MIN, VCO_MAX]; */
    Ifx_UReg_32Bit reserved_27:3;     /* [29:27] 保留 */
    Ifx_UReg_32Bit INSEL:2;           /* [31:30] Input Selection - INSEL(rw)
                                       * PLL输入时钟源选择:
                                       *   - 00: 来自某个内部源;
                                       *   - 01: 来自XOSC(外部晶振);
                                       *   - 10: 来自BACKUP时钟;
                                       *   - 11: 保留或其他源;
                                       * 在你启用XOSC后, EnablePLL0通常会把INSEL设为"XOSC",
                                       * 这样PLL0吃的是外部晶振; */
} Ifx_SCU_SYSPLLCON0_Bits;

/* SYSPLLCON1: 系统PLL输出分频(K2) */
typedef struct _Ifx_SCU_SYSPLLCON1_Bits
{
    Ifx_UReg_32Bit K2DIV:3;           /* [2:0] K2-Divider Value - K2DIV(rw)
                                       * 输出分频因子K2:
                                       *   fPLL0 = fVCO/K2
                                       * 配合NDIV/PDIV一起决定CPU/SRI/SPB的频率:
                                       *   - 例如:fIN=20MHz, PDIV=2, NDIV=60 → fVCO=600MHz;
                                       *            K2=2 → fPLL0=300MHz; */
    Ifx_UReg_32Bit reserved_3:29;     /* [31:3] 保留 */
} Ifx_SCU_SYSPLLCON1_Bits;

/* SYSPLLCON2:PLL频率调制(Spread-Spectrum)配置 */
typedef struct _Ifx_SCU_SYSPLLCON2_Bits
{
    Ifx_UReg_32Bit MODCFG:16;         /* [15:0] Modulation Configuration - MODCFG(rw)
                                       * 当MODEN=1时, 这个字段定义:
                                       *   - 调制深度(frequency deviation);
                                       *   - 调制频率(sweep速度);
                                       *   - 波形(三角/锯齿)等参数;
                                       * 用于"展开频谱", 减小EMI尖峰;
                                       * 具体bit含义要看PLL Modulation专门章节; */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_SYSPLLCON2_Bits;

/* System PLL Status Register */
typedef struct _Ifx_SCU_SYSPLLSTAT_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0:0] internal Reserved */
    Ifx_UReg_32Bit PWDSTAT:1;         /* [1:1] PLL处于power-saving/bypass模式(省电), VCO不工作, 系统时钟直接从别的源(比如XOSC或BACKUP)走 (rh) */
    Ifx_UReg_32Bit LOCK:1;            /* [2:2] 1: PLL已经锁定在你配置的N/P/K2那些参数指定的频率 (rh) */
    Ifx_UReg_32Bit reserved_3:2;      /* [4:3] internal Reserved */
    Ifx_UReg_32Bit K2RDY:1;           /* [5:5] 修改SYSPLLCON1.K2之后, 等该位=1, 表示"新的K2分频值已经被硬件接纳/稳定" (rh) */
    Ifx_UReg_32Bit reserved_6:1;      /* [6:6] internal Reserved */
    Ifx_UReg_32Bit MODRUN:1;          /* [7:7] 1: 频率调制正在运行, PLL输出不是一个死固定值, 而是轻微抖动 (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /* [31:8] internal Reserved */
} Ifx_SCU_SYSPLLSTAT_Bits;

/* TRAPCLR:Trap Clear Register —— 用"写1清除"方式清除SCU Trap请求标志 */
typedef struct _Ifx_SCU_TRAPCLR_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /* [0] Clear Trap Request Flag ESR0T - ESR0T(w)
                                       * 写1: 清除"ESR0T trap请求标志";
                                       * 一般在处理完对应trap后, 用它清掉状态; */
    Ifx_UReg_32Bit ESR1T:1;           /* [1] 清ESR1T trap标志(同理) */
    Ifx_UReg_32Bit TRAP2:1;           /* [2] 清TRAP2 trap标志 */
    Ifx_UReg_32Bit SMUT:1;            /* [3] 清SMU相关trap标志(SMU告警触发的trap) */
    Ifx_UReg_32Bit reserved_4:28;     /* [31:4] 保留 */
} Ifx_SCU_TRAPCLR_Bits;

/* TRAPDIS0:Trap Disable Register 0 —— 控制"某个Trap是否送到某个CPU" */
typedef struct _Ifx_SCU_TRAPDIS0_Bits
{
    Ifx_UReg_32Bit CPU0ESR0T:1;       /* [0] Disable Trap Request ESR0T on CPU0 - CPU0ESR0T(rw)
                                       * =1:ESR0T这路trap不再送到CPU0;
                                       * =0: 正常送到CPU0; */
    Ifx_UReg_32Bit CPU0ESR1T:1;       /* [1] 禁用ESR1T → CPU0的trap */
    Ifx_UReg_32Bit CPU0TRAP2T:1;      /* [2] 禁用TRAP2T → CPU0的trap */
    Ifx_UReg_32Bit CPU0SMUT:1;        /* [3] 禁用SMUT → CPU0的trap */
    Ifx_UReg_32Bit reserved_4:4;      /* [7:4] 保留 */
    Ifx_UReg_32Bit CPU1ESR0T:1;       /* [8] Disable Trap Request ESR0T on CPU1 - CPU1ESR0T(rw) */
    Ifx_UReg_32Bit CPU1ESR1T:1;       /* [9] 禁用ESR1T → CPU1 */
    Ifx_UReg_32Bit CPU1TRAP2T:1;      /* [10] 禁用TRAP2T → CPU1 */
    Ifx_UReg_32Bit CPU1SMUT:1;        /* [11] 禁用SMUT → CPU1 */
    Ifx_UReg_32Bit reserved_12:4;     /* [15:12] 保留 */
    Ifx_UReg_32Bit CPU2ESR0T:1;       /* [16] Disable Trap Request ESR0T on CPU2 - CPU2ESR0T(rw) */
    Ifx_UReg_32Bit CPU2ESR1T:1;       /* [17] 禁用ESR1T → CPU2 */
    Ifx_UReg_32Bit CPU2TRAP2T:1;      /* [18] 禁用TRAP2T → CPU2 */
    Ifx_UReg_32Bit CPU2SMUT:1;        /* [19] 禁用SMUT → CPU2 */
    Ifx_UReg_32Bit reserved_20:4;     /* [23:20] 保留 */
    Ifx_UReg_32Bit CPU3ESR0T:1;       /* [24] Disable Trap Request ESR0T on CPU3 - CPU3ESR0T(rw) */
    Ifx_UReg_32Bit CPU3ESR1T:1;       /* [25] 禁用ESR1T → CPU3 */
    Ifx_UReg_32Bit CPU3TRAP2T:1;      /* [26] 禁用TRAP2T → CPU3 */
    Ifx_UReg_32Bit CPU3SMUT:1;        /* [27] 禁用SMUT → CPU3 */
    Ifx_UReg_32Bit reserved_28:4;     /* [31:28] 保留 */
} Ifx_SCU_TRAPDIS0_Bits;

/* TRAPDIS1: 目前全保留(为未来扩展预留空间) */
typedef struct _Ifx_SCU_TRAPDIS1_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /* [3:0] 保留 */
    Ifx_UReg_32Bit reserved_4:4;      /* [7:4] 保留 */
    Ifx_UReg_32Bit reserved_8:4;      /* [11:8] 保留 */
    Ifx_UReg_32Bit reserved_12:4;     /* [15:12] 保留 */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_TRAPDIS1_Bits;

/* TRAPSET:Trap Set Register —— 用写1方式"手动触发"Trap标志 */
typedef struct _Ifx_SCU_TRAPSET_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /* [0] Set Trap Request Flag ESR0T - ESR0T(w)
                                       * 写1: 手动置位ESR0T trap标志, 相当于模拟ESR0 trap事件,
                                       * 用于测试trap处理/分发逻辑; */
    Ifx_UReg_32Bit ESR1T:1;           /* [1] Set ESR1T trap标志 */
    Ifx_UReg_32Bit TRAP2:1;           /* [2] Set TRAP2 trap标志 */
    Ifx_UReg_32Bit SMUT:1;            /* [3] Set SMUT trap标志(模拟SMU alarm trap) */
    Ifx_UReg_32Bit reserved_4:28;     /* [31:4] 保留 */
} Ifx_SCU_TRAPSET_Bits;

/* TRAPSTAT:Trap Status Register —— 当前有哪些trap标志处于置位状态 */
typedef struct _Ifx_SCU_TRAPSTAT_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /* [0] ESR0 Trap Request Flag - ESR0T(rh)
                                       * =1: 当前有ESR0相关trap请求; */
    Ifx_UReg_32Bit ESR1T:1;           /* [1] ESR1 Trap Request Flag */
    Ifx_UReg_32Bit TRAP2:1;           /* [2] Trap2相关trap标志 */
    Ifx_UReg_32Bit SMUT:1;            /* [3] SMU Alarm Trap Request Flag - SMUT
                                       * =1:SMU告警触发了trap; */
    Ifx_UReg_32Bit reserved_4:28;     /* [31:4] 保留 */
} Ifx_SCU_TRAPSTAT_Bits;

/* CPUy WDTCON0: 每个CPU本地Watchdog的控制寄存器0 */
typedef struct _Ifx_SCU_WDTCPU_CON0_Bits
{
    Ifx_Strict_32Bit ENDINIT:1;       /* [0] End-of-Initialization Control Bit - ENDINIT(rwh)
                                       * CPU级别的ENDINIT锁:
                                       *   - =1: 保护开启, 受保护寄存器(比如BIV/BTV/某些CLC)不可写;
                                       *   - =0: 短暂解锁窗口, 可写这些寄存器;
                                       * 操作流程:
                                       *   - 通过密码序列 + LCK + PW修改ENDINIT,
                                       *   - 高层封装就是unlock_wdtcon()/lock_wdtcon(); */
    Ifx_Strict_32Bit LCK:1;           /* [1] Lock Bit to Control Access to WDTxCON0 - LCK(rwh)
                                       * 看门狗寄存器访问锁:
                                       *   - LCK=1:WDTCPU_CON0被锁住, 不能随便改ENDINIT/PW/REL;
                                       *   - LCK=0: 配合密码写入, 可以改这些字段;
                                       * 密码/lock序列错误会在WDTCPU_SR.AE里报Access Error; */
    Ifx_Strict_32Bit PW:14;           /* [15:2] User-Definable Password Field for Access to WDTxCON0 - PW(rwh)
                                       * CPU看门狗的密码字段:
                                       *   - 修改ENDINIT/LCK/REL之前, 必须写正确的PW序列;
                                       *   - 防止随便写导致误关/误调WDT;
                                       * 高层库(wdtcon.c)已经封装了密码更新, 在应用层不建议直接操作PW; */
    Ifx_Strict_32Bit REL:16;          /* [31:16] Reload Value for the WDT(also Time Check Value) - REL(rw)
                                       * WDT重载值(也就是Timeout检查值):
                                       *   - 喂狗时, Watchdog计数器会被重装为REL;
                                       *   - 根据WDT输入时钟频率和预分频, 这决定了"多长时间没喂就触发"; */
} Ifx_SCU_WDTCPU_CON0_Bits;

/* CPUy WDTCON1:CPU Watchdog的附加配置 */
typedef struct _Ifx_SCU_WDTCPU_CON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /* [0] 保留 */
    Ifx_UReg_32Bit reserved_1:1;      /* [1] 保留 */
    Ifx_UReg_32Bit IR0:1;             /* [2] Input Frequency Request Control - IR1, IR0(rw)
                                       * 与IR1一起选择WDT输入时钟的频率档位(同Safety SEICON1那种IR1/IR0):
                                       *   - 不同频点 → REL相同的情况下, 真正的Timeout时间不同; */
    Ifx_UReg_32Bit DR:1;              /* [3] Disable Request Control Bit - DR(rw)
                                       * 请求禁用WDT:
                                       *   - =1: 请求关闭Watchdog;
                                       *   - =0: 允许Watchdog正常工作;
                                       * 在安全项目中, 通常不允许随便把DR=1, 除非在严格控制下; */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit IR1:1;             /* [5] Input Frequency Request Control - IR1(rw)
                                       * 与IR0配套决定WDT输入时钟频率; */
    Ifx_UReg_32Bit UR:1;              /* [6] Unlock Restriction Request Control Bit - UR(rw)
                                       * 请求修改"解锁限制策略", 限制/放宽哪些操作允许修改WDT参数; */
    Ifx_UReg_32Bit PAR:1;             /* [7] Password Auto-sequence Request Bit - PAR(rw)
                                       * 请求"自动执行密码序列":
                                       *   - 在某些模式下, 硬件可以替你完成密码滚动/更新,
                                       *     减少软件自己管理密码的复杂度; */
    Ifx_UReg_32Bit TCR:1;             /* [8] Counter Check Request Bit - TCR(rw)
                                       * 请求执行一次"计数器自检"(Timer Check),
                                       * 对应状态在WDTCPU_SR.TCS/TCT中体现; */
    Ifx_UReg_32Bit TCTR:7;            /* [15:9] Timer Check Tolerance Request - TCTR(rw)
                                       * Timer Check的允许偏差范围请求值(Tolerance);
                                       *   - 真实Timer Check结果的偏差不应超过TCTR,
                                       *     否则视为计数器/时钟有问题; */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_WDTCPU_CON1_Bits;

/* CPUy WDT Status Register:CPU看门狗当前状态灯 */
typedef struct _Ifx_SCU_WDTCPU_SR_Bits
{
    Ifx_UReg_32Bit AE:1;              /* [0] Watchdog Access Error Status Flag - AE(rh)
                                       * =1: 最近一次对WDTCON0/1的访问违反密码/锁定规则,
                                       *      产生访问错误; */
    Ifx_UReg_32Bit OE:1;              /* [1] Watchdog Overflow Error Status Flag - OE(rh)
                                       * =1:WDT溢出/超时(没有及时喂狗); */
    Ifx_UReg_32Bit IS0:1;             /* [2] Watchdog Input Clock Status - IS0(rh)
                                       * 与IS1一起反映当前WDT输入时钟的频率/源状态; */
    Ifx_UReg_32Bit DS:1;              /* [3] Watchdog Enable/Disable Status Flag - DS(rh)
                                       * =1:WDT当前处于Disable状态(被关掉);
                                       * =0:WDT Enable(正常监控); */
    Ifx_UReg_32Bit TO:1;              /* [4] Watchdog Time-Out Mode Flag - TO(rh)
                                       * 标记当前处于"Time-Out Mode"还是"Window Mode"等, 视具体设计而定; */
    Ifx_UReg_32Bit IS1:1;             /* [5] 与IS0组合 */
    Ifx_UReg_32Bit US:1;              /* [6] SMU Unlock Restriction Status Flag - US(rh)
                                       * 反映与SMU联动的"解锁限制"状态; */
    Ifx_UReg_32Bit PAS:1;             /* [7] Password Auto-sequence Status Flag - PAS(rh)
                                       * =1: 自动密码序列功能已激活/完成; */
    Ifx_UReg_32Bit TCS:1;             /* [8] Timer Check Status Flag - TCS(rh)
                                       * 计数器自检是否通过; */
    Ifx_UReg_32Bit TCT:7;             /* [15:9] Timer Check Tolerance - TCT(rh)
                                       * 实际Timer Check误差, 供诊断使用; */
    Ifx_UReg_32Bit TIM:16;            /* [31:16] Timer Value - TIM(rh)
                                       * 当前WDT计数器的值(剩余多少"ticks"才会溢出); */
} Ifx_SCU_WDTCPU_SR_Bits;

/* WDTS_CON0:Safety Watchdog的控制寄存器0(结构与CPU WDT类似) */
typedef struct _Ifx_SCU_WDTS_CON0_Bits
{
    Ifx_Strict_32Bit ENDINIT:1;       /* [0] Safety End-of-Initialization Control - ENDINIT(rwh)
                                       * Safety域的ENDINIT:
                                       *   - 控制SCU/PLL/CCU/DMA等"安全关键寄存器"的写保护;
                                       *   - 由unlock_safety_wdtcon()/lock_safety_wdtcon()控制; */
    Ifx_Strict_32Bit LCK:1;           /* [1] Lock Bit - LCK(rwh)
                                       * 和CPU WDT一样, 是Safety WDT的访问锁; */
    Ifx_Strict_32Bit PW:14;           /* [15:2] Safety WDT密码字段 - PW(rwh) */
    Ifx_Strict_32Bit REL:16;          /* [31:16] Safety WDT重载值 - REL(rw)
                                       * Safety Watchdog的超时时间基准; */
} Ifx_SCU_WDTS_CON0_Bits;

/* WDTS_CON1:Safety Watchdog附加控制 */
typedef struct _Ifx_SCU_WDTS_CON1_Bits
{
    Ifx_UReg_32Bit CLRIRF:1;          /* [0] Clear Internal Reset Flag - CLRIRF(rwh)
                                       * 写1: 清除Safety WDT的"内部复位标志",
                                       * 一般在处理完相关故障/复位之后调用; */
    Ifx_UReg_32Bit reserved_1:1;      /* [1] 保留 */
    Ifx_UReg_32Bit IR0:1;             /* [2] Input Frequency Request Control - IR1, IR0(rw)
                                       * 与IR1配合选择Safety WDT输入时钟频率; */
    Ifx_UReg_32Bit DR:1;              /* [3] Disable Request Control Bit - DR(rw)
                                       * 请求禁用Safety WDT(极高危操作, 安全项目一般不允许长期DR=1); */
    Ifx_UReg_32Bit reserved_4:1;      /* [4] 保留 */
    Ifx_UReg_32Bit IR1:1;             /* [5] Input Frequency Request Control - IR1(rw) */
    Ifx_UReg_32Bit UR:1;              /* [6] Unlock Restriction Request - UR(rw) */
    Ifx_UReg_32Bit PAR:1;             /* [7] Password Auto-sequence Request - PAR(rw) */
    Ifx_UReg_32Bit TCR:1;             /* [8] Counter Check Request - TCR(rw) */
    Ifx_UReg_32Bit TCTR:7;            /* [15:9] Timer Check Tolerance Request - TCTR(rw) */
    Ifx_UReg_32Bit reserved_16:16;    /* [31:16] 保留 */
} Ifx_SCU_WDTS_CON1_Bits;

/* Safety Watchdog Status Register: 安全狗当前状态总览 */
typedef struct _Ifx_SCU_WDTS_SR_Bits
{
  Ifx_UReg_32Bit AE:1;              /* [0] Watchdog Access Error Status Flag - AE(rh)
                                     * =1: 上一次(或最近)对WDTS_CON0/CON1的访问序列有问题,
                                     *     比如:
                                     *       - 密码PW写错;
                                     *       - LCK没解就硬改;
                                     *       - ENDINIT解锁流程不按规定走;
                                     * 你可以把AE理解成:
                                     *   "有人在乱摸Safety WDT/ENDINIT的寄存器",
                                     *   这是要进诊断日志的;
                                     * 典型用法:
                                     *   - 解锁/锁Safety ENDINIT后检查一下:
                                     *       if(WDTS.SR.B.AE) { 说明你解锁流程写错了, 或者有非法访问 } */
  Ifx_UReg_32Bit OE:1;              /* [1] Watchdog Overflow Error Status Flag - OE(rh)
                                     * =1:Safety WDT 超时/溢出 —— 也就是"没按时喂狗";
                                     * 对安全狗来说, 这通常意味着:
                                     *   - 系统/安全代码卡死了;
                                     *   - 或没按窗口要求进行服务;
                                     *   - 一般会触发复位或SMU安全反应;
                                     * 启动后, 读OE可以知道:
                                     *   "上一次复位是否因为Safety WDT的超时引起"; */
  Ifx_UReg_32Bit IS0:1;             /* [2] Watchdog Input Clock Status - IS0(rh)
                                     * 和IS1一起, 表示当前Safety WDT使用的输入时钟"是哪一档"、
                                     * 以及该时钟状态是否正常;
                                     * 这两个状态位对应WDTS_CON1.IR1/IR0的实际结果:
                                     *   - IR1/IR0选谁做WDT输入时钟;
                                     *   - IS1/IS0反馈当前这个时钟源是否OK; */
  Ifx_UReg_32Bit DS:1;              /* [3] Watchdog Enable/Disable Status Flag - DS(rh)
                                     * =1:Safety WDT当前处于"禁用状态"(Disabled);
                                     * =0:Safety WDT被启用(Enabled), 在正常计数;
                                     * 这个位和WDTS_CON1.DR相关(Disable Request);
                                     * 安全项目里:
                                     *   - 正常运行阶段, 你期望DS=0;
                                     *   - 如果发现DS=1, 要么在特殊测试模式, 要么就是严重配置问题; */
  Ifx_UReg_32Bit TO:1;              /* [4] Watchdog Time-Out Mode Flag - TO(rh)
                                     * 标记WDT当前是否处于某种Time-Out模式(而不是Window Mode等);
                                     * 实际含义要结合芯片文档, 但对于状态判断:
                                     *   - 可以用来确认Safety WDT当前正按照设定的"超时策略"工作; */
  Ifx_UReg_32Bit IS1:1;             /* [5] Watchdog Input Clock Status - IS1(rh)
                                     * 与IS0组合使用:
                                     *   - 例如IS1:IS0不同组合代表:
                                     *       00: 某个低频源;
                                     *       01: 备份时钟;
                                     *       10:PLL分频;
                                     *   - 若选用的时钟源失效, 这两个位也可能提示状态异常; */
  Ifx_UReg_32Bit US:1;              /* [6] SMU Unlock Restriction Status Flag - US(rh)
                                     * "SMU解锁限制"状态:
                                     *   - Safety WDT与SMU之间可能有联动规则(例如某些SMU状态下禁止解锁WDT);
                                     *   - US=1可能意味着当前处于"被限制禁止某些解锁/禁用操作"的状态;
                                     * 工程上:
                                     *   - 如果你发现无法按预期修改安全狗配置, 可以看看US;
                                     *   - 安全策略一般会规定在某些报警级别下锁死WDT的配置修改; */
  Ifx_UReg_32Bit PAS:1;             /* [7] Password Auto-sequence Status Flag - PAS(rh)
                                     * =1:Password Auto-sequence功能正在运行/已启用,
                                     *      即硬件自动帮你处理某些密码滚动/序列(对应WDTS_CON1.PAR);
                                     * 对于高级安全用例:
                                     *   - 可以使用自动密码序列减少软件错误,
                                     *   - PAS反映该功能当前状态; */
  Ifx_UReg_32Bit TCS:1;             /* [8] Timer Check Status Flag - TCS(rh)
                                     * 计时器自检结果标志:
                                     *   - =1: 最近一次Timer Check通过;
                                     *   - =0:Timer Check失败或未运行;
                                     * Timer Check用于验证:
                                     *   - WDT计数器、时钟路径是否按照期待的节奏在走,
                                     *   - 防止"狗被时钟故障骗过去"; */
  Ifx_UReg_32Bit TCT:7;             /* [15:9] Timer Check Tolerance - TCT(rh)
                                     * 实际Timer Check测得的"误差/容差值":
                                     *   - 对应WDTS_CON1.TCTR(请求容差);
                                     *   - TCT是实际测量出来的误差, 可用于诊断:
                                     *       - 时钟偏差是否在安全范围;
                                     *       - 超出过容差没有;
                                     * 在安全分析/台架调试时, 这个字段很有用, 能量化定时器精度; */
  Ifx_UReg_32Bit TIM:16;            /* [31:16] Timer Value - TIM(rh)
                                     * 当前Safety WDT的计数器值(剩余tick数);
                                     * - WDT在递减模式:TIM从REL往0数;
                                     * - WDT在递增模式:TIM从0往上数到某个门限;
                                     * 用途:
                                     *   - 调试时看"当前距离超时还有多长时间";
                                     *   - 做软监控时可以snapshot TIM, 看看喂狗是否按期发生; */
} Ifx_SCU_WDTS_SR_Bits;


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_scu_Registers_union
 * \{   */
/* Access Enable Register 00   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_ACCEN00_Bits B;           /* Bitfield access */
} Ifx_SCU_ACCEN00;

/* Access Enable Register 01   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_ACCEN01_Bits B;           /* Bitfield access */
} Ifx_SCU_ACCEN01;

/* Access Enable Register 10   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_ACCEN10_Bits B;           /* Bitfield access */
} Ifx_SCU_ACCEN10;

/* Access Enable Register 11   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_ACCEN11_Bits B;           /* Bitfield access */
} Ifx_SCU_ACCEN11;

/* Application Reset Disable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_ARSTDIS_Bits B;           /* Bitfield access */
} Ifx_SCU_ARSTDIS;

/* CCU Clock Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON0_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON0;

/* CCU Clock Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON1_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON1;

/* CCU Clock Control Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON2_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON2;

/* CCU Clock Control Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON3_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON3;

/* CCU Clock Control Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON4_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON4;

/* CCU Clock Control Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON5_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON5;

/* CCU Clock Control Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON6_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON6;

/* CCU Clock Control Register 7   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON7_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON7;

/* CCU Clock Control Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON8_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON8;

/* CCU Clock Control Register 9   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CCUCON9_Bits B;           /* Bitfield access */
} Ifx_SCU_CCUCON9;

/* Chip Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_CHIPID_Bits B;            /* Bitfield access */
} Ifx_SCU_CHIPID;

/* Core Die Temperature Sensor Limit Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_DTSCLIM_Bits B;           /* Bitfield access */
} Ifx_SCU_DTSCLIM;

/* Core Die Temperature Sensor Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_DTSCSTAT_Bits B;          /* Bitfield access */
} Ifx_SCU_DTSCSTAT;

/* ENDINIT Global Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EICON0_Bits B;            /* Bitfield access */
} Ifx_SCU_EICON0;

/* ENDINIT Global Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EICON1_Bits B;            /* Bitfield access */
} Ifx_SCU_EICON1;

/* External Input Channel Register i   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EICR_Bits B;              /* Bitfield access */
} Ifx_SCU_EICR;

/* External Input Filter Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EIFILT_Bits B;            /* Bitfield access */
} Ifx_SCU_EIFILT;

/* External Input Flag Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EIFR_Bits B;              /* Bitfield access */
} Ifx_SCU_EIFR;

/* ENDINIT Timeout Counter Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EISR_Bits B;              /* Bitfield access */
} Ifx_SCU_EISR;

/* Emergency Stop Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EMSR_Bits B;              /* Bitfield access */
} Ifx_SCU_EMSR;

/* Emergency Stop Software set and clear register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EMSSW_Bits B;             /* Bitfield access */
} Ifx_SCU_EMSSW;

/* ESR${x} Input Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_ESRCFGX_ESRCFGX_Bits B;    /* Bitfield access */
} Ifx_SCU_ESRCFGX_ESRCFGX;

/* ESR Output Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_ESROCFG_Bits B;           /* Bitfield access */
} Ifx_SCU_ESROCFG;

/* External Clock Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_EXTCON_Bits B;            /* Bitfield access */
} Ifx_SCU_EXTCON;

/* Fractional Divider Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_FDR_Bits B;               /* Bitfield access */
} Ifx_SCU_FDR;

/* Flag Modification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_FMR_Bits B;               /* Bitfield access */
} Ifx_SCU_FMR;

/* Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_ID_Bits B;                /* Bitfield access */
} Ifx_SCU_ID;

/* Flag Gating Register ${j}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_IGCR_Bits B;              /* Bitfield access */
} Ifx_SCU_IGCR;

/* ESR Input Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_IN_Bits B;                /* Bitfield access */
} Ifx_SCU_IN;

/* Input/Output Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_IOCR_Bits B;              /* Bitfield access */
} Ifx_SCU_IOCR;

/* Logic BIST Control 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_LBISTCTRL0_Bits B;        /* Bitfield access */
} Ifx_SCU_LBISTCTRL0;

/* Logic BIST Control 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_LBISTCTRL1_Bits B;        /* Bitfield access */
} Ifx_SCU_LBISTCTRL1;

/* Logic BIST Control 2 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_LBISTCTRL2_Bits B;        /* Bitfield access */
} Ifx_SCU_LBISTCTRL2;

/* Logic BIST Control 3 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_LBISTCTRL3_Bits B;        /* Bitfield access */
} Ifx_SCU_LBISTCTRL3;

/* LCL CPU0 and CPU2 Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_LCLCON0_Bits B;           /* Bitfield access */
} Ifx_SCU_LCLCON0;

/* LCL CPU1 and CPU3 Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_LCLCON1_Bits B;           /* Bitfield access */
} Ifx_SCU_LCLCON1;

/* LCL Test Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_LCLTEST_Bits B;           /* Bitfield access */
} Ifx_SCU_LCLTEST;

/* Manufacturer Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_MANID_Bits B;             /* Bitfield access */
} Ifx_SCU_MANID;

/* ESR Output Modification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_OMR_Bits B;               /* Bitfield access */
} Ifx_SCU_OMR;

/* OSC Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_OSCCON_Bits B;            /* Bitfield access */
} Ifx_SCU_OSCCON;

/* ESR Output Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_OUT_Bits B;               /* Bitfield access */
} Ifx_SCU_OUT;

/* Overlay Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_OVCCON_Bits B;            /* Bitfield access */
} Ifx_SCU_OVCCON;

/* Overlay Enable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_OVCENABLE_Bits B;         /* Bitfield access */
} Ifx_SCU_OVCENABLE;

/* Pad Disable Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PDISC_Bits B;             /* Bitfield access */
} Ifx_SCU_PDISC;

/* ESR Pad Driver Mode Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PDR_Bits B;               /* Bitfield access */
} Ifx_SCU_PDR;

/* Pattern Detection Result Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PDRR_Bits B;              /* Bitfield access */
} Ifx_SCU_PDRR;

/* Peripheral PLL Configuration 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PERPLLCON0_Bits B;        /* Bitfield access */
} Ifx_SCU_PERPLLCON0;

/* Peripheral PLL Configuration 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PERPLLCON1_Bits B;        /* Bitfield access */
} Ifx_SCU_PERPLLCON1;

/* Peripheral PLL Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PERPLLSTAT_Bits B;        /* Bitfield access */
} Ifx_SCU_PERPLLSTAT;

/* Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMCSR0_Bits B;            /* Bitfield access */
} Ifx_SCU_PMCSR0;

/* Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMCSR1_Bits B;            /* Bitfield access */
} Ifx_SCU_PMCSR1;

/* Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMCSR2_Bits B;            /* Bitfield access */
} Ifx_SCU_PMCSR2;

/* Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMCSR3_Bits B;            /* Bitfield access */
} Ifx_SCU_PMCSR3;

/* Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMCSR4_Bits B;            /* Bitfield access */
} Ifx_SCU_PMCSR4;

/* Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMCSR5_Bits B;            /* Bitfield access */
} Ifx_SCU_PMCSR5;

/* Power Management Status Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMSTAT0_Bits B;           /* Bitfield access */
} Ifx_SCU_PMSTAT0;

/* Standby and Wake-up Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMSWCR1_Bits B;           /* Bitfield access */
} Ifx_SCU_PMSWCR1;

/* Power Management Transition Control and Status Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMTRCSR0_Bits B;          /* Bitfield access */
} Ifx_SCU_PMTRCSR0;

/* Power Management Transition Control and Status Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMTRCSR1_Bits B;          /* Bitfield access */
} Ifx_SCU_PMTRCSR1;

/* Power Management Transition Control and Status Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMTRCSR2_Bits B;          /* Bitfield access */
} Ifx_SCU_PMTRCSR2;

/* Power Management Transition Control and Status Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_PMTRCSR3_Bits B;          /* Bitfield access */
} Ifx_SCU_PMTRCSR3;

/* Reset Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_RSTCON_Bits B;            /* Bitfield access */
} Ifx_SCU_RSTCON;

/* Additional Reset Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_RSTCON2_Bits B;           /* Bitfield access */
} Ifx_SCU_RSTCON2;

/* Reset Configuration Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_RSTCON3_Bits B;           /* Bitfield access */
} Ifx_SCU_RSTCON3;

/* Reset Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_RSTSTAT_Bits B;           /* Bitfield access */
} Ifx_SCU_RSTSTAT;

/* Safety ENDINIT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SEICON0_Bits B;           /* Bitfield access */
} Ifx_SCU_SEICON0;

/* Safety ENDINIT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SEICON1_Bits B;           /* Bitfield access */
} Ifx_SCU_SEICON1;

/* Safety ENDINIT Timeout Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SEISR_Bits B;             /* Bitfield access */
} Ifx_SCU_SEISR;

/* Start-up Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_STCON_Bits B;             /* Bitfield access */
} Ifx_SCU_STCON;

/* Start-up Memory Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_STMEM1_Bits B;            /* Bitfield access */
} Ifx_SCU_STMEM1;

/* Start-up Memory Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_STMEM2_Bits B;            /* Bitfield access */
} Ifx_SCU_STMEM2;

/* Start-up Memory Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_STMEM3_Bits B;            /* Bitfield access */
} Ifx_SCU_STMEM3;

/* Start-up Memory Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_STMEM4_Bits B;            /* Bitfield access */
} Ifx_SCU_STMEM4;

/* Start-up Memory Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_STMEM5_Bits B;            /* Bitfield access */
} Ifx_SCU_STMEM5;

/* Start-up Memory Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_STMEM6_Bits B;            /* Bitfield access */
} Ifx_SCU_STMEM6;

/* Start-up Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_STSTAT_Bits B;            /* Bitfield access */
} Ifx_SCU_STSTAT;

/* Address Map Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SWAPCTRL_Bits B;          /* Bitfield access */
} Ifx_SCU_SWAPCTRL;

/* Software Reset Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SWRSTCON_Bits B;          /* Bitfield access */
} Ifx_SCU_SWRSTCON;

/* System Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SYSCON_Bits B;            /* Bitfield access */
} Ifx_SCU_SYSCON;

/* System PLL Configuration 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SYSPLLCON0_Bits B;        /* Bitfield access */
} Ifx_SCU_SYSPLLCON0;

/* System PLL Configuration 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SYSPLLCON1_Bits B;        /* Bitfield access */
} Ifx_SCU_SYSPLLCON1;

/* System PLL Configuration 2 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SYSPLLCON2_Bits B;        /* Bitfield access */
} Ifx_SCU_SYSPLLCON2;

/* System PLL Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_SYSPLLSTAT_Bits B;        /* Bitfield access */
} Ifx_SCU_SYSPLLSTAT;

/* Trap Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_TRAPCLR_Bits B;           /* Bitfield access */
} Ifx_SCU_TRAPCLR;

/* Trap Disable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_TRAPDIS0_Bits B;          /* Bitfield access */
} Ifx_SCU_TRAPDIS0;

/* Trap Disable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_TRAPDIS1_Bits B;          /* Bitfield access */
} Ifx_SCU_TRAPDIS1;

/* Trap Set Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_TRAPSET_Bits B;           /* Bitfield access */
} Ifx_SCU_TRAPSET;

/* Trap Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_TRAPSTAT_Bits B;          /* Bitfield access */
} Ifx_SCU_TRAPSTAT;

/* CPU${y} WDT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_WDTCPU_CON0_Bits B;       /* Bitfield access */
} Ifx_SCU_WDTCPU_CON0;

/* CPU${y} WDT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_WDTCPU_CON1_Bits B;       /* Bitfield access */
} Ifx_SCU_WDTCPU_CON1;

/* CPU${y} WDT Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_WDTCPU_SR_Bits B;         /* Bitfield access */
} Ifx_SCU_WDTCPU_SR;

/* Safety WDT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_WDTS_CON0_Bits B;         /* Bitfield access */
} Ifx_SCU_WDTS_CON0;

/* Safety WDT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_WDTS_CON1_Bits B;         /* Bitfield access */
} Ifx_SCU_WDTS_CON1;

/* Safety WDT Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /* Unsigned access */
    Ifx_SReg_32Bit I;                 /* Signed access */
    Ifx_SCU_WDTS_SR_Bits B;           /* Bitfield access */
} Ifx_SCU_WDTS_SR;


/******************************************************************************/
/******************************************************************************/
/* IfxSfr_Scu_ESRCFGx_struct */
/******************************************************************************/
/* ESRCFGX object */
/* ESRCFGX object:ESR输入配置寄存器"壳子", 一眼看出这是一个单寄存器对象 */
typedef volatile struct _Ifx_SCU_ESRCFGX
{
  Ifx_SCU_ESRCFGX_ESRCFGX ESRCFGX;   /* 0, ESR${x} Input Configuration Register
                                     *
                                     * 这一行的意思其实很简单:
                                     *   - 这个struct代表"某一路ESR的输入配置寄存器块";
                                     *   - 里面只有一个成员:ESRCFGX;
                                     *   - 类型 `Ifx_SCU_ESRCFGX_ESRCFGX` 是真正的寄存器定义(通常是union { U; B; } 那种),
                                     *     你前面看到的大部分 *_Bits都是给它用的;
                                     *
                                     * 换句话说:
                                     *   Ifx_SCU_ESRCFGX就是一个"包装", 里面包着这个ESRx的配置寄存器ESRCFGX:
                                     *
                                     *   SCU_ESRCFG0.ESRCFGX  → 配ESR0的输入特性
                                     *   SCU_ESRCFG1.ESRCFGX  → 配ESR1的输入特性
                                     *   ...
                                     *
                                     * 至于ESRCFGX这个寄存器里面有啥字段(比如:
                                     *   - 选择这个ESR输入接到哪个ERU通道;
                                     *   - 配上升沿/下降沿检测;
                                     *   - 配滤波/施密特触发/同步等)
                                     * 要看对应的 `Ifx_SCU_ESRCFGX_ESRCFGX_Bits` 定义或SCU手册"ESR input configuration"章节; */
} Ifx_SCU_ESRCFGX;


/* WDTCPU object: 某个CPU的本地看门狗寄存器"打包对象"
 * 把这颗CPU的Watchdog三个关键寄存器(CON0/CON1/SR)放在一个struct里,
 * 方便按CPU维度访问; */
typedef volatile struct _Ifx_SCU_WDTCPU
{
  Ifx_SCU_WDTCPU_CON0 CON0;   /* 0x0, CPUy WDT Control Register 0
                               *
                               * 前面我们已经拆过:
                               *   - ENDINIT:CPU级ENDINIT锁控制位(保护部分寄存器写访问)
                               *   - LCK: 锁定位(控制能否修改CON0)
                               *   - PW: 密码字段(写CON0之前的认证)
                               *   - REL: 重载值(看门狗超时时间基准)
                               *
                               * 高层封装(如unlock_wdtcon()/lock_wdtcon())就是在按密码协议写这个寄存器; */
  Ifx_SCU_WDTCPU_CON1 CON1;   /* 0x4, CPUy WDT Control Register 1
                               *
                               * Watchdog的附加配置:
                               *   - IR1/IR0: 选择WDT输入时钟档位 → 决定WDT tick周期;
                               *   - DR:Disable Request(请求关WDT, 安全项目慎用);
                               *   - UR/PAR: 解锁限制 & 自动密码序列控制;
                               *   - TCR/TCTR: 计数器自检的请求与误差容限配置;
                               *
                               * 一般只在初始化阶段设置一次, 或在安全自检流程中临时改; */
  Ifx_SCU_WDTCPU_SR   SR;     /* 0x8, CPUy WDT Status Register
                               *
                               * 当前Watchdog状态灯:
                               *   - AE: 访问错误(密码/锁规则没遵守);
                               *   - OE: 溢出/超时(没按时喂狗);
                               *   - IS1/IS0: 当前WDT输入时钟状态(频率源是否正确);
                               *   - DS:WDT是否处于Disable状态;
                               *   - TO:Time-Out模式标志;
                               *   - US/PAS: 解锁限制/密码自动序列状态;
                               *   - TCS/TCT: 计数器自检状态与实际误差;
                               *   - TIM: 当前计数器数值(距超时还有多少tick);
                               *
                               * 调试/诊断时, 你会读SR来判断:
                               *   - 看门狗有没有被关掉;
                               *   - 有没有超时过;
                               *   - 时钟/密码/自检有没有问题; */
} Ifx_SCU_WDTCPU;

/* WDTS object:Safety Watchdog(全局安全看门狗)的寄存器打包对象
 * 和WDTCPU很像, 只不过这是"安全域那颗狗", 不是每个CPU自己的小狗; */
typedef volatile struct _Ifx_SCU_WDTS
{
  Ifx_SCU_WDTS_CON0 CON0;   /* 0x0, Safety WDT Control Register 0
                             *
                             * 结构与CPU WDTCON0一致, 但作用范围更"大":
                             *   - ENDINIT:Safety ENDINIT锁(保护所有"安全关键寄存器"的写访问)
                             *   - LCK: 锁定位(控制能否修改CON0)
                             *   - PW: 安全WDT的密码字段
                             *   - REL: 安全WDT的重载值(安全超时基准)
                             *
                             * 高层封装(unlock_safety_wdtcon()/lock_safety_wdtcon())
                             * 就是在按密码和解锁序列操作这个寄存器; */
  Ifx_SCU_WDTS_CON1 CON1;   /* 0x4, Safety WDT Control Register 1
                             *
                             * Safety Watchdog的附加控制:
                             *   - CLRIRF: 清内部复位标志;
                             *   - IR1/IR0: 选择安全WDT输入时钟频率;
                             *   - DR: 请求禁用Safety WDT(高危, 一般禁用);
                             *   - UR/PAR: 解锁限制 & 自动密码序列;
                             *   - TCR/TCTR: 计数器自检请求以及允许的误差范围;
                             *
                             * 这些字段主要影响:
                             *   - 安全看门狗"多久超时"、
                             *   - 能否完全关掉、
                             *   - 自检机制是否工作正常; */
  Ifx_SCU_WDTS_SR   SR;     /* 0x8, Safety WDT Status Register
                             *
                             * Safety WDT当前状态灯:
                             *   - AE: 访问错误(密码/锁规则没遵守);
                             *   - OE: 溢出/超时(安全狗没被喂, 或超出窗口);
                             *   - IS1/IS0: 当前输入时钟状态(频率源是否正常);
                             *   - DS: 安全WDT是否被禁用;
                             *   - TO: 是否处于Time-Out模式;
                             *   - US:SMU解锁限制状态;
                             *   - PAS: 密码自动序列状态;
                             *   - TCS/TCT: 自检状态与实际误差;
                             *   - TIM: 当前计数器值(离超时还剩多少tick);
                             *
                             * 调试/诊断:
                             *   - 复位后可查看OE/AE/US/TCS等判断:
                             *       是不是安全看门狗导致的复位;
                             *       解锁/自检/输入时钟有没有异常; */
} Ifx_SCU_WDTS;

/* SCU"大总管"对象: 整个System Control Unit的寄存器一览表
 * 你平时看到的SYSPLLCONx/CCUCONx/RSTCON/WDT/ERU/LBIST/Overlay/Power Management等,
 * 全都挂在这个struct下面;
 */
typedef volatile struct _Ifx_SCU
{
  Ifx_UReg_8Bit       reserved_0[8];      /* 0x000, 保留 */
  Ifx_SCU_ID          ID;                 /* 0x008, SCU模块自身的"ID":MODREV/MODTYPE/MODNUMBER; */
  Ifx_UReg_8Bit       reserved_C[4];      /* 0x00C, 保留 */
  Ifx_SCU_OSCCON      OSCCON;             /* 0x010, 外部晶振XOSC控制: 模式、增益、电容、看门狗等; */
  Ifx_SCU_SYSPLLSTAT  SYSPLLSTAT;         /* 0x014, System PLL Status Register */
  Ifx_SCU_SYSPLLCON0  SYSPLLCON0;         /* 0x018, System PLL Configuration 0 */
  Ifx_SCU_SYSPLLCON1  SYSPLLCON1;         /* 0x01C, System PLL Configuration 1 */
  Ifx_SCU_SYSPLLCON2  SYSPLLCON2;         /* 0x020, System PLL Configuration 2 */
  Ifx_SCU_PERPLLSTAT  PERPLLSTAT;         /* 0x024, Peripheral PLL Status */
  Ifx_SCU_PERPLLCON0  PERPLLCON0;         /* 0x028, Peripheral PLL Configuration 0 */
  Ifx_SCU_PERPLLCON1  PERPLLCON1;         /* 0x02C, Peripheral PLL Configuration 1 */
  Ifx_SCU_CCUCON0     CCUCON0;            /* 0x030, Clock Control 0:FSYSTEM→SRI/SPB/STM/GTM等分频 */
  Ifx_SCU_CCUCON1     CCUCON1;            /* 0x034, Clock Control 1:MCAN/I2C/MSC/QSPI分频和源选择 */
  Ifx_SCU_FDR         FDR;                /* 0x038, Fractional Divider Register(通用分数分频器) */
  Ifx_SCU_EXTCON      EXTCON;             /* 0x03C, 外部时钟输出控制(EXTCLK0/1) */
  Ifx_SCU_CCUCON2     CCUCON2;            /* 0x040, Clock Control 2:ASCLIN时钟等 */
  Ifx_SCU_CCUCON3     CCUCON3;            /* 0x044, Clock Control 3:PLL/Backup/SPB监控开关 */
  Ifx_SCU_CCUCON4     CCUCON4;            /* 0x048, Clock Control 4:Backup时钟监控阈值 */
  Ifx_SCU_CCUCON5     CCUCON5;            /* 0x04C, Clock Control 5:GETH/MCANH分频 */
  Ifx_SCU_RSTSTAT     RSTSTAT;            /* 0x050, Reset Status: 是谁把我复位了? */
  Ifx_UReg_8Bit       reserved_54[4];     /* 0x054, 保留 */
  Ifx_SCU_RSTCON      RSTCON;             /* 0x058, Reset Configuration: 各个reset源的复位等级配置 */
  Ifx_SCU_ARSTDIS     ARSTDIS;            /* 0x05C, Application Reset Disable: 禁用STMx做App Reset */
  Ifx_SCU_SWRSTCON    SWRSTCON;           /* 0x060, Software Reset Request: 软件复位开关 */
  Ifx_SCU_RSTCON2     RSTCON2;            /* 0x064, 附加Reset控制 & 用户信息区 */
  Ifx_SCU_RSTCON3     RSTCON3;            /* 0x068, 保留 */
  Ifx_UReg_8Bit       reserved_6C[4];     /* 0x06C, 保留 */
  Ifx_SCU_ESRCFGX     ESRCFGX[2];         /* 0x070, ESR0/1输入配置(边沿检测) */
  Ifx_SCU_ESROCFG     ESROCFG;            /* 0x078, ESR Output Configuration(App Reset指示等) */
  Ifx_SCU_SYSCON      SYSCON;             /* 0x07C, System Control: 杂项系统控制位 */
  Ifx_SCU_CCUCON6     CCUCON6;            /* 0x080, CPU0DIV:CPU0主频分频 */
  Ifx_SCU_CCUCON7     CCUCON7;            /* 0x084, CPU1DIV */
  Ifx_SCU_CCUCON8     CCUCON8;            /* 0x088, CPU2DIV */
  Ifx_SCU_CCUCON9     CCUCON9;            /* 0x08C, CPU3DIV */
  Ifx_UReg_8Bit       reserved_90[12];    /* 0x090, 保留 */
  Ifx_SCU_PDR         PDR;                /* 0x09C, ESR Pad Driver Mode: 驱动强度/电平等级 */
  Ifx_SCU_IOCR        IOCR;               /* 0x0A0, ESR0/1 IO模式配置(输入/输出等) */
  Ifx_SCU_OUT         OUT;                /* 0x0A4, ESR输出latch */
  Ifx_SCU_OMR         OMR;                /* 0x0A8, ESR输出set/clear(写1置/清) */
  Ifx_SCU_IN          IN;                 /* 0x0AC, ESR输入当前电平状态 */
  Ifx_UReg_8Bit       reserved_B0[16];    /* 0x0B0, 保留 */
  Ifx_SCU_STSTAT      STSTAT;             /* 0x0C0, 启动状态(HWCFG/FTM/模式/RAM自检结果等) */
  Ifx_SCU_STCON       STCON;              /* 0x0C4, 启动配置:Flash Config扇区访问/Startup Protection */
  Ifx_SCU_PMCSR0      PMCSR0;             /* 0x0C8, pmcsr[0]: 电源管理控制 & 状态(通常CPU0域) */
  Ifx_SCU_PMCSR1      PMCSR1;             /* 0x0CC, pmcsr[1] */
  Ifx_SCU_PMCSR2      PMCSR2;             /* 0x0D0, pmcsr[2] */
  Ifx_SCU_PMCSR3      PMCSR3;             /* 0x0D4, pmcsr[3] */
  Ifx_SCU_PMCSR4      PMCSR4;             /* 0x0D8, pmcsr[4] */
  Ifx_SCU_PMCSR5      PMCSR5;             /* 0x0DC, pmcsr[5] */
  Ifx_UReg_8Bit       reserved_E0[4];     /* 0x0E0, 保留 */
  Ifx_SCU_PMSTAT0     PMSTAT0;            /* 0x0E4, Power Management Status:CPU/Lockstep域供电状态 */
  Ifx_SCU_PMSWCR1     PMSWCR1;            /* 0x0E8, Standby/Wakeup控制: 哪个CPU控Sleep/Standby等 */
  Ifx_UReg_8Bit       reserved_EC[16];    /* 0x0EC, 保留 */
  Ifx_SCU_EMSR        EMSR;               /* 0x0FC, Emergency Stop(紧急停机输入)配置/状态 */
  Ifx_SCU_EMSSW       EMSSW;              /* 0x100, Emergency Stop软件模拟/清除寄存器 */
  Ifx_SCU_DTSCSTAT    DTSCSTAT;           /* 0x104, 内部温度传感器测量值 */
  Ifx_SCU_DTSCLIM     DTSCLIM;            /* 0x108, 温度上下限 & 中断配置 */
  Ifx_UReg_8Bit       reserved_10C[20];   /* 0x10C, 保留 */
  Ifx_SCU_TRAPDIS1    TRAPDIS1;           /* 0x120, Trap Disable(扩展/暂未用) */
  Ifx_SCU_TRAPSTAT    TRAPSTAT;           /* 0x124, Trap Status(ESR0T/ESR1T/TRAP2/SMUT) */
  Ifx_SCU_TRAPSET     TRAPSET;            /* 0x128, Trap Set(软件置位trap标志) */
  Ifx_SCU_TRAPCLR     TRAPCLR;            /* 0x12C, Trap Clear(写1清除trap标志) */
  Ifx_SCU_TRAPDIS0    TRAPDIS0;           /* 0x130, Trap Disable 0: 各CPU是否接收这些trap */
  Ifx_SCU_LCLCON0     LCLCON0;            /* 0x134, CPU0/CPU2 Lockstep控制/状态 */
  Ifx_SCU_LCLCON1     LCLCON1;            /* 0x138, CPU1/CPU3 Lockstep控制/状态 */
  Ifx_SCU_LCLTEST     LCLTEST;            /* 0x13C, Lockstep自测触发 */
  Ifx_SCU_CHIPID      CHIPID;             /* 0x140, 芯片身份信息(修订、封装、容量等) */
  Ifx_SCU_MANID       MANID;              /* 0x144, 制造商/部门ID */
  Ifx_UReg_8Bit       reserved_148[4];    /* 0x148, 保留 */
  Ifx_SCU_SWAPCTRL    SWAPCTRL;           /* 0x14C, Address Map控制(Boot Bank/地址映射) */
  Ifx_UReg_8Bit       reserved_150[20];   /* 0x150, 保留 */
  Ifx_SCU_LBISTCTRL0  LBISTCTRL0;         /* 0x164, LBIST控制0(启动/pattern数/错误注入等) */
  Ifx_SCU_LBISTCTRL1  LBISTCTRL1;         /* 0x168, LBIST控制1(seed/split/body/freq) */
  Ifx_SCU_LBISTCTRL2  LBISTCTRL2;         /* 0x16C, LBIST控制2(长度) */
  Ifx_SCU_LBISTCTRL3  LBISTCTRL3;         /* 0x170, LBIST控制3(签名结果) */
  Ifx_UReg_8Bit       reserved_174[16];   /* 0x174, 保留 */
  Ifx_SCU_STMEM1      STMEM1;             /* 0x184, 启动参数存储寄存器1 */
  Ifx_SCU_STMEM2      STMEM2;             /* 0x188, 启动参数存储寄存器2 */
  Ifx_SCU_PDISC       PDISC;              /* 0x18C, Pad Disable:ESR0/1 pad物理断开控制 */
  Ifx_UReg_8Bit       reserved_190[8];    /* 0x190, 保留 */
  Ifx_SCU_PMTRCSR0    PMTRCSR0;           /* 0x198, 电源过渡控制/状态(Load Jump + Voltage Droop计时器) */
  Ifx_SCU_PMTRCSR1    PMTRCSR1;           /* 0x19C, 上述计时器的比较值 */
  Ifx_SCU_PMTRCSR2    PMTRCSR2;           /* 0x1A0, Load Jump Timer运行状态/计数 */
  Ifx_SCU_PMTRCSR3    PMTRCSR3;           /* 0x1A4, Voltage Droop Timer状态/计数 */
  Ifx_UReg_8Bit       reserved_1A8[24];   /* 0x1A8, 保留 */
  Ifx_SCU_STMEM3      STMEM3;             /* 0x1C0, Start-up Memory 3 */
  Ifx_SCU_STMEM4      STMEM4;             /* 0x1C4, Start-up Memory 4 */
  Ifx_SCU_STMEM5      STMEM5;             /* 0x1C8, Start-up Memory 5 */
  Ifx_SCU_STMEM6      STMEM6;             /* 0x1CC, Start-up Memory 6 */
  Ifx_UReg_8Bit       reserved_1D0[16];   /* 0x1D0, 保留 */
  Ifx_SCU_OVCENABLE   OVCENABLE;          /* 0x1E0, Overlay Enable: 按CPU打开/关闭overlay功能 */
  Ifx_SCU_OVCCON      OVCCON;             /* 0x1E4, Overlay控制: 选CPU + start/stop overlay + DCache invalidate等 */
  Ifx_UReg_8Bit       reserved_1E8[36];   /* 0x1E8, 保留 */
  Ifx_SCU_EIFILT      EIFILT;             /* 0x20C, 外部输入滤波配置 */
  Ifx_SCU_EICR        EICR[4];            /* 0x210, External Input Channels配置(EXIS/FEN/REN/LDEN/INP) */
  Ifx_SCU_EIFR        EIFR;               /* 0x220, 外部事件标志 */
  Ifx_SCU_FMR         FMR;                /* 0x224, Flag Modification: 写1置/清各通道INTF标志 */
  Ifx_SCU_PDRR        PDRR;               /* 0x228, Pattern Detection结果(各通道pattern是否匹配) */
  Ifx_SCU_IGCR        IGCR[4];            /* 0x22C, Flag Gating: 把INTF/pattern组合成事件/中断 */
  Ifx_UReg_8Bit       reserved_23C[16];   /* 0x23C, 保留 */
  Ifx_SCU_WDTCPU      WDTCPU[4];          /* 0x24C, 每个CPU的本地Watchdog(ENDINIT+WDT) */
  Ifx_UReg_8Bit       reserved_27C[32];   /* 0x27C, 保留 */
  Ifx_SCU_EICON0      EICON0;             /* 0x29C, 全局ENDINIT控制0 */
  Ifx_SCU_EICON1      EICON1;             /* 0x2A0, 全局ENDINIT控制1 */
  Ifx_SCU_EISR        EISR;               /* 0x2A4, ENDINIT Timeout状态 */
  Ifx_SCU_WDTS        WDTS;               /* 0x2A8, Safety Watchdog(含安全ENDINIT) */
  Ifx_SCU_SEICON0     SEICON0;            /* 0x2B4, Safety ENDINIT控制0 */
  Ifx_SCU_SEICON1     SEICON1;            /* 0x2B8, Safety ENDINIT控制1 */
  Ifx_SCU_SEISR       SEISR;              /* 0x2BC, Safety ENDINIT Timeout状态 */
  Ifx_UReg_8Bit       reserved_2C0[304];  /* 0x2C0, 大段保留, 用于未来扩展 */
  Ifx_SCU_ACCEN11     ACCEN11;            /* 0x3F0, Access Enable 11(保留/高半字视角) */
  Ifx_SCU_ACCEN10     ACCEN10;            /* 0x3F4, Access Enable 10(Safety视角) */
  Ifx_SCU_ACCEN01     ACCEN01;            /* 0x3F8, Access Enable 01(保留/高半字视角) */
  Ifx_SCU_ACCEN00     ACCEN00;            /* 0x3FC, Access Enable 00(功能视角) */
} Ifx_SCU;

/******************************************************************************/


/******************************************************************************/

/******************************************************************************/

#endif  /* IFXSCU_REGDEF_H */
